C51 COMPILER V9.50a   YXT                                                                  11/24/2017 09:02:04 PAGE 1   


C51 COMPILER V9.50a, COMPILATION OF MODULE YXT
OBJECT MODULE PLACED IN .\Output\yxt.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Code\yxt.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Include) DEFINE(FOSC_16000
                    -0) DEBUG OBJECTEXTEND PRINT(.\LST\yxt.lst) OBJECT(.\Output\yxt.obj)

line level    source

   1          #include "stm8s.h"
*** WARNING C318 IN LINE 1 OF Code\yxt.c: can't open file 'stm8s.h'
   2          #include "yxt.h"
*** ERROR C320 IN LINE 267 OF Code\bike.h: "Please select a release!!!"
*** ERROR C320 IN LINE 273 OF Code\bike.h: "Not defined LCD_TYPE"
*** ERROR C141 IN LINE 309 OF Code\bike.h: syntax error near 'uint8_t'
*** ERROR C129 IN LINE 309 OF Code\bike.h: missing ';' before 'bLFlashType'
   3          
   4          
   5          unsigned char YXT_Buf[12];
   6          unsigned char YXT_Status[9];
   7          unsigned char YXT_RxBit,YXT_RxData;
   8          unsigned char YXT_Update=0;
   9          
  10          
  11          void YXT_Init(void)
  12          {
  13                  CLK_PeripheralClockConfig(CLK_PERIPHERAL_TIMER1, ENABLE);
  14          
  15                  //TIM1_DeInit();
  16                  TIM1_TimeBaseInit(31,TIM1_COUNTERMODE_UP,0xFFFF,0);
  17                  TIM1_PWMIConfig(TIM1_CHANNEL_1,TIM1_ICPOLARITY_FALLING,TIM1_ICSELECTION_DIRECTTI,TIM1_ICPSC_DIV1,0x0F);
  18                  TIM1_SelectSlaveMode(TIM1_SLAVEMODE_RESET);
  19                  TIM1_SelectInputTrigger(TIM1_TS_TI1FP1);
  20                  TIM1_ClearFlag(TIM1_FLAG_UPDATE | TIM1_FLAG_CC2);
  21                  TIM1_ITConfig(TIM1_IT_CC2,ENABLE);
  22                  TIM1_Cmd(ENABLE);
  23          
  24                  GPIO_Init(GPIOC, GPIO_PIN_6, GPIO_MODE_IN_FL_NO_IT);    //YXT
  25                  
  26                  YXT_Update = 0;
  27          }
  28          
  29          
  30          void YXT_Tim_Receive(uint16_t duty)
  31          {
  32                  int8_t PlusCode;
  33                  uint8_t checksum;
  34                  uint8_t i;
  35                  
  36                  YXT_RxData <<= 1;
  37                  if ( duty > 15 && duty < 42 ) {
  38                          YXT_RxData |= 0x01;
  39                  }
  40            
  41                  if ( (++YXT_RxBit % 8) == 0 ){
  42                          YXT_Buf[YXT_RxBit/8-1] = YXT_RxData;
  43                          YXT_RxData = 0;
  44                  }
  45                  
  46                  if ( YXT_RxBit >= 96 ){
  47                          YXT_RxBit = 0;
  48                          
  49                          checksum = YXT_Buf[0];
C51 COMPILER V9.50a   YXT                                                                  11/24/2017 09:02:04 PAGE 2   

  50                          for(i=1;i<12;i++)
  51                                  checksum ^= YXT_Buf[i];
  52                  
  53                          if ( checksum ) return ;
  54                          if ( YXT_Update ) return ;
  55                          
  56                          if ( YXT_Buf[0] == 0x1F ){      //YXT_WXJX
  57                                  PlusCode = (char)(YXT_Buf[1]+0x9E);
  58                                  PlusCode = (char)(PlusCode ^ 0x47);
  59                                  PlusCode = (char)(PlusCode + 0x8D);
  60                                  PlusCode = (char)(PlusCode ^ 0x3A);
  61                                  PlusCode = (char)(PlusCode + (YXT_Buf[2] >> 4));
  62                                  PlusCode = (char)(PlusCode ^ 0xCB);
  63                                  PlusCode = (char)(PlusCode + 0x03);
  64                                  PlusCode = (char)(PlusCode ^ 0xAC);
  65                                  PlusCode = PlusCode & 0x7F;
  66                          } else if ( YXT_Buf[0] == 0x25 ){       //协昌-台州本铃
  67                                  PlusCode = (char)(YXT_Buf[1]+0xEA);
  68                                  PlusCode = (char)(PlusCode ^ 0xDB);
  69                                  PlusCode = (char)(PlusCode + 0xBF);
  70                                  PlusCode = (char)(PlusCode ^ 0x5A);
  71                                  PlusCode = (char)(PlusCode + (YXT_Buf[2] >> 4));
  72                                  PlusCode = (char)(PlusCode ^ 0x4B);
  73                                  PlusCode = (char)(PlusCode + 0xDB);
  74                                  PlusCode = (char)(PlusCode ^ 0xBD);
  75                                  PlusCode = PlusCode & 0x7F;
  76                          } else if ( YXT_Buf[0] == 0x2B ){       //YXT_LQGS
  77                                  PlusCode = (char)(YXT_Buf[1]+0x2C);
  78                                  PlusCode = (char)(PlusCode ^ 0x6F);
  79                                  PlusCode = (char)(PlusCode + 0xDF);
  80                                  PlusCode = (char)(PlusCode ^ 0x7A);
  81                                  PlusCode = (char)(PlusCode + (YXT_Buf[2] >> 4));
  82                                  PlusCode = (char)(PlusCode ^ 0x2B);
  83                                  PlusCode = (char)(PlusCode + 0x0D);
  84                                  PlusCode = (char)(PlusCode ^ 0xC2);
  85                                  PlusCode = PlusCode & 0x7F;
  86                          } else if ( YXT_Buf[0] == 0x08 ){       //英科尔、晶汇本铃
  87                                  PlusCode = 0;
  88                          } else {
  89                                  PlusCode = YXT_Buf[10];
  90                          }
  91                          
  92                          //YXT_Status[0] = YXT_Buf[2] - (((YXT_Buf[2] >> 4))*0x10);
  93                          YXT_Status[1] = YXT_Buf[3] - PlusCode;
  94                          YXT_Status[2] = YXT_Buf[4] - PlusCode;
  95                          //YXT_Status[3] = YXT_Buf[5] - PlusCode;
  96                          //YXT_Status[4] = YXT_Buf[6];
  97                          YXT_Status[5] = YXT_Buf[7] - PlusCode;
  98                          YXT_Status[6] = YXT_Buf[8] - PlusCode;
  99                          //YXT_Status[7] = YXT_Buf[9] - PlusCode;
 100                          //YXT_Status[8] = YXT_Buf[10]- PlusCode;
 101                          
 102                          YXT_Update = 1;
 103                  }
 104                  if ( duty > 2560 ) {
 105                          YXT_RxBit  = 0;
 106                          YXT_RxData = 0;
 107                  }
 108          }
 109          
 110          void YXT_Task(BIKE_STATUS *bike,BIKE_CONFIG* config)
 111          {
C51 COMPILER V9.50a   YXT                                                                  11/24/2017 09:02:04 PAGE 3   

 112                  static unsigned int pre_tick=0;
 113                  uint32_t speed;
 114                  
 115                  if ( YXT_Update ){
 116                          pre_tick = Get_SysTick();
 117                          bike->bYXTERR = 0;
 118          
 119          #ifdef JIKE13050        
                              if ( (YXT_Status[1] & (1<<7)) ) bike->bYXTECO  = 1; else bike->bYXTECO  = 0;
              #endif
 122                          if ( (YXT_Status[1] & (1<<6)) ) bike->bHallERR = 1; else bike->bHallERR = 0;
 123                          if ( (YXT_Status[1] & (1<<5)) ) bike->bWheelERR= 1; else bike->bWheelERR= 0; 
 124                          if ( (YXT_Status[1] & (1<<4)) ) bike->bECUERR  = 1; else bike->bECUERR  = 0;
 125                  //      if ( (YXT_Status[1] & (1<<2)) ) bike->bCruise  = 1; else bike->bCruise  = 0;
 126                          if ( (YXT_Status[1] & (1<<0)) ) bike->bPhaseERR= 1; else bike->bPhaseERR= 0;
 127          
 128                          if ( (YXT_Status[2] & (1<<5)) ) bike->bBraked  = 1; else bike->bBraked  = 0;
 129          #ifdef JIKE13050        
                              if ( (YXT_Status[2] & (1<<3)) ) bike->bYXTRCHG = 1; else bike->bYXTRCHG = 0;
              #endif
 132                  
 133                          bike->ucSpeedMode = ((YXT_Status[2]>>5)&0x04)|(YXT_Status[2]&0x03);
 134                          speed = ((unsigned int )YXT_Status[5]<<8) | YXT_Status[6];
 135                          speed = speed*5/60;     //600->50Km/h
 136                          bike->ucYXT_Speed       = speed;
 137                          bike->ucSpeed           = speed*1000UL/config->uiYXT_SpeedScale;
 138          
 139                          YXT_Update = 0;  
 140                  } else if ( Get_ElapseTick(pre_tick) > 3000 ){
 141                          bike->bYXTERR   = 1;
 142                          bike->bHallERR  = 0;
 143                          bike->bPhaseERR = 0;
 144                          bike->bWheelERR = 0;
 145                          bike->bECUERR   = 0;
 146                  }       
 147          }
 148          

C51 COMPILATION COMPLETE.  1 WARNING(S),  4 ERROR(S)

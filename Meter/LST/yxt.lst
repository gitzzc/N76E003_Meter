C51 COMPILER V9.50a   YXT                                                                  12/04/2017 14:02:12 PAGE 1   


C51 COMPILER V9.50a, COMPILATION OF MODULE YXT
OBJECT MODULE PLACED IN .\Output\yxt.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Code\yxt.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Include) DEFINE(FOSC
                    -_160000) DEBUG OBJECTEXTEND PRINT(.\LST\yxt.lst) OBJECT(.\Output\yxt.obj)

line level    source

   1          #include "N76E003.h"
   2          #include "SFR_Macro.h"
   3          #include "Function_define.h"
   4          #include "Common.h"
   5          #include "Delay.h"
   6          
   7          #include "yxt.h"
   8          
   9          
  10          unsigned char YXT_Buf[12];
  11          unsigned char YXT_Status[9];
  12          unsigned char YXT_RxBit,YXT_RxData;
  13          unsigned char YXT_Update=0;
  14          
  15          
  16          /*********************************************************************************************************
             -***
  17          *    Timer2 Capture interrupt subroutine
  18          **********************************************************************************************************
             -**/
  19          void Capture_ISR (void) interrupt 12
  20          {
  21   1              unsigned char cl,ch;
  22   1              static uint16_t high,low;
  23   1              
  24   1              clr_CAPF0;                      // clear capture0 interrupt flag
  25   1              cl = C0L;                       // For capture mode CxL/CxH with data capture from I/O pin
  26   1              ch = C0H;                                                                                       
  27   1              clr_TF2;
  28   1              
  29   1              if ( P12 == 1 ){
  30   2                      low = ((uint16_t)ch<<8)|cl;
  31   2              } else {
  32   2                      high = ((uint16_t)ch<<8)|cl;
  33   2                      YXT_Tim_Receive(low*100/(low+high));
  34   2              }
  35   1      }
  36          
  37          void YXT_Init(void)
  38          {
  39   1              TIMER2_DIV_32;
  40   1              TIMER2_CAP0_Capture_Mode;
  41   1              IC0_P12_CAP0_BothEdge_Capture;
  42   1      
  43   1              set_ECAP;                                   //Enable Capture interrupt
  44   1              set_TR2;                                    //Triger Timer2
  45   1              
  46   1              YXT_Update = 0;
  47   1      }
  48          
  49          
  50          void YXT_Tim_Receive(uint16_t duty)
  51          {
  52   1              int8_t PlusCode;
C51 COMPILER V9.50a   YXT                                                                  12/04/2017 14:02:12 PAGE 2   

  53   1              uint8_t checksum;
  54   1              uint8_t i;
  55   1              
  56   1              YXT_RxData <<= 1;
  57   1              if ( duty > 15 && duty < 42 ) {
  58   2                      YXT_RxData |= 0x01;
  59   2              }
  60   1        
  61   1              if ( (++YXT_RxBit % 8) == 0 ){
  62   2                      YXT_Buf[YXT_RxBit/8-1] = YXT_RxData;
  63   2                      YXT_RxData = 0;
  64   2              }
  65   1              
  66   1              if ( YXT_RxBit >= 96 ){
  67   2                      YXT_RxBit = 0;
  68   2                      
  69   2                      checksum = YXT_Buf[0];
  70   2                      for(i=1;i<12;i++)
  71   2                              checksum ^= YXT_Buf[i];
  72   2              
  73   2                      if ( checksum ) return ;
  74   2                      if ( YXT_Update ) return ;
  75   2                      
  76   2                      if ( YXT_Buf[0] == 0x1F ){      //YXT_WXJX
  77   3                              PlusCode = (char)(YXT_Buf[1]+0x9E);
  78   3                              PlusCode = (char)(PlusCode ^ 0x47);
  79   3                              PlusCode = (char)(PlusCode + 0x8D);
  80   3                              PlusCode = (char)(PlusCode ^ 0x3A);
  81   3                              PlusCode = (char)(PlusCode + (YXT_Buf[2] >> 4));
  82   3                              PlusCode = (char)(PlusCode ^ 0xCB);
  83   3                              PlusCode = (char)(PlusCode + 0x03);
  84   3                              PlusCode = (char)(PlusCode ^ 0xAC);
  85   3                              PlusCode = PlusCode & 0x7F;
  86   3                      } else if ( YXT_Buf[0] == 0x25 ){       //协昌-台州本铃
  87   3                              PlusCode = (char)(YXT_Buf[1]+0xEA);
  88   3                              PlusCode = (char)(PlusCode ^ 0xDB);
  89   3                              PlusCode = (char)(PlusCode + 0xBF);
  90   3                              PlusCode = (char)(PlusCode ^ 0x5A);
  91   3                              PlusCode = (char)(PlusCode + (YXT_Buf[2] >> 4));
  92   3                              PlusCode = (char)(PlusCode ^ 0x4B);
  93   3                              PlusCode = (char)(PlusCode + 0xDB);
  94   3                              PlusCode = (char)(PlusCode ^ 0xBD);
  95   3                              PlusCode = PlusCode & 0x7F;
  96   3                      } else if ( YXT_Buf[0] == 0x2B ){       //YXT_LQGS
  97   3                              PlusCode = (char)(YXT_Buf[1]+0x2C);
  98   3                              PlusCode = (char)(PlusCode ^ 0x6F);
  99   3                              PlusCode = (char)(PlusCode + 0xDF);
 100   3                              PlusCode = (char)(PlusCode ^ 0x7A);
 101   3                              PlusCode = (char)(PlusCode + (YXT_Buf[2] >> 4));
 102   3                              PlusCode = (char)(PlusCode ^ 0x2B);
 103   3                              PlusCode = (char)(PlusCode + 0x0D);
 104   3                              PlusCode = (char)(PlusCode ^ 0xC2);
 105   3                              PlusCode = PlusCode & 0x7F;
 106   3                      } else if ( YXT_Buf[0] == 0x08 ){       //英科尔、晶汇本铃
 107   3                              PlusCode = 0;
 108   3                      } else {
 109   3                              PlusCode = YXT_Buf[10];
 110   3                      }
 111   2                      
 112   2                      //YXT_Status[0] = YXT_Buf[2] - (((YXT_Buf[2] >> 4))*0x10);
 113   2                      YXT_Status[1] = YXT_Buf[3] - PlusCode;
 114   2                      YXT_Status[2] = YXT_Buf[4] - PlusCode;
C51 COMPILER V9.50a   YXT                                                                  12/04/2017 14:02:12 PAGE 3   

 115   2                      //YXT_Status[3] = YXT_Buf[5] - PlusCode;
 116   2                      //YXT_Status[4] = YXT_Buf[6];
 117   2                      YXT_Status[5] = YXT_Buf[7] - PlusCode;
 118   2                      YXT_Status[6] = YXT_Buf[8] - PlusCode;
 119   2                      //YXT_Status[7] = YXT_Buf[9] - PlusCode;
 120   2                      //YXT_Status[8] = YXT_Buf[10]- PlusCode;
 121   2                      
 122   2                      YXT_Update = 1;
 123   2              }
 124   1              if ( duty > 2560 ) {
 125   2                      YXT_RxBit  = 0;
 126   2                      YXT_RxData = 0;
 127   2              }
 128   1      }
 129          
 130          void YXT_Task(BIKE_STATUS *bike,BIKE_CONFIG* config)
 131          {
 132   1              static unsigned int pre_tick=0;
 133   1              uint32_t speed;
 134   1              
 135   1              if ( YXT_Update ){
 136   2                      pre_tick = Get_SysTick();
 137   2                      bike->bYXTERR = 0;
 138   2      
 139   2      #ifdef JIKE13050        
                              if ( (YXT_Status[1] & (1<<7)) ) bike->bECO     = 1; else bike->bECO     = 0;
              #endif
 142   2                      if ( (YXT_Status[1] & (1<<6)) ) bike->bHallERR = 1; else bike->bHallERR = 0;
 143   2                      if ( (YXT_Status[1] & (1<<5)) ) bike->bWheelERR= 1; else bike->bWheelERR= 0; 
 144   2                      if ( (YXT_Status[1] & (1<<4)) ) bike->bECUERR  = 1; else bike->bECUERR  = 0;
 145   2              //      if ( (YXT_Status[1] & (1<<2)) ) bike->bCruise  = 1; else bike->bCruise  = 0;
 146   2                      if ( (YXT_Status[1] & (1<<0)) ) bike->bPhaseERR= 1; else bike->bPhaseERR= 0;
 147   2      
 148   2                      if ( (YXT_Status[2] & (1<<5)) ) bike->bBraked  = 1; else bike->bBraked  = 0;
 149   2      #ifdef JIKE13050        
                              if ( (YXT_Status[2] & (1<<3)) ) bike->bRCHG    = 1; else bike->bRCHG    = 0;
                              if ( (YXT_Status[2] & (1<<6)) ) bike->bParking = 0; else bike->bParking = 1;
                              
              #endif
 154   2              
 155   2                      bike->ucSpeedMode = ((YXT_Status[2]>>5)&0x04)|(YXT_Status[2]&0x03);
 156   2                      speed = ((unsigned int )YXT_Status[5]<<8) | YXT_Status[6];
 157   2                      speed = speed*5/60;     //600->50Km/h
 158   2                      bike->ucYXT_Speed       = speed;
 159   2                      bike->ucSpeed           = bike->ucYXT_Speed*1000UL/config->uiYXT_SpeedScale;
 160   2      
 161   2                      YXT_Update = 0;  
 162   2              } else if ( Get_ElapseTick(pre_tick) > 3000 ){
 163   2                      bike->bYXTERR   = 1;
 164   2                      bike->bHallERR  = 0;
 165   2                      bike->bPhaseERR = 0;
 166   2                      bike->bWheelERR = 0;
 167   2                      bike->bECUERR   = 0;
 168   2              }       
 169   1          
 170   1              if ( bike->bYXTERR      == 0 ){
 171   2                      bike->ucSpeed   = bike->ucYXT_Speed*1000UL/config->uiYXT_SpeedScale;
 172   2          }
 173   1      }
 174          


C51 COMPILER V9.50a   YXT                                                                  12/04/2017 14:02:12 PAGE 4   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1127    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     30      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

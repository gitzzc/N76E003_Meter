C51 COMPILER V9.50a   GPIO                                                                 12/04/2017 00:08:34 PAGE 1   


C51 COMPILER V9.50a, COMPILATION OF MODULE GPIO
OBJECT MODULE PLACED IN .\Output\GPIO.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Code\GPIO.C LARGE BROWSE INCDIR(..\Include) DEFINE(FOSC_160000) DEBUG OBJEC
                    -TEXTEND PRINT(.\LST\GPIO.lst) OBJECT(.\Output\GPIO.obj)

line level    source

   1          /*--------------------------------------------------------------------------------------------------------
             --*/
   2          /*                                                                                                        
             - */
   3          /* Copyright(c) 2017 Nuvoton Technology Corp. All rights reserved.                                        
             - */
   4          /*                                                                                                        
             - */
   5          /*--------------------------------------------------------------------------------------------------------
             --*/
   6          
   7          //********************************************************************************************************
             -***
   8          //  Website: http://www.nuvoton.com
   9          //  E-Mail : MicroC-8bit@nuvoton.com
  10          //  Date   : Jan/21/2017
  11          //********************************************************************************************************
             -***
  12          
  13          //********************************************************************************************************
             -***
  14          //  File Function: N76E003 GPIO demo code
  15          //********************************************************************************************************
             -***
  16          #include <stdlib.h>
  17          #include <string.h>
  18          
  19          #include "N76E003.h"
  20          #include "SFR_Macro.h"
  21          #include "Function_define.h"
  22          #include "Common.h"
  23          #include "Delay.h"
  24          
  25          #include "adc.h"
  26          #include "bl55072.h"
  27          #include "display.h"
  28          #include "bike.h"
  29          #include "YXT.h"
  30          
  31          
  32          /**
  33            * @brief  Configures the IWDG to generate a Reset if it is not refreshed at the
  34            *         correct time. 
  35            * @param  None
  36            * @retval None
  37            */
  38          static void WDG_Config(void)
  39          {
  40   1      }
  41          
  42          //enum GPIO_PORT = {GPIO0,GPIO1,GPIO2,GPIO3};
  43          //enum GPIO_PIN  = {PIN0,PIN1,PIN2,PIN3,PIN4,PIN5,PIN6,PIN7};
  44          
  45          void GPIO_Init(uint8_t port, uint8_t pin, uint8_t mode)
C51 COMPILER V9.50a   GPIO                                                                 12/04/2017 00:08:34 PAGE 2   

  46          {
  47   1              switch ( mode ){
  48   2                      case GPIO_QUASI:
  49   2                              switch(port){
  50   3                                      case 0x80:      P0M1&=~(1<<pin);P0M2&=~(1<<pin);break;
  51   3                                      case 0x90:      P1M1&=~(1<<pin);P1M2&=~(1<<pin);break;
  52   3                                      case 0xB0:      P3M1&=~(1<<pin);P3M2&=~(1<<pin);break;
  53   3                                      default:        break;
  54   3                              }
  55   2                              break;
  56   2                      case GPIO_PUSH_PULL:
  57   2                              switch(port){
  58   3                                      case 0x80:      P0M1&=~(1<<pin);P0M2|=(1<<pin);break;
  59   3                                      case 0x90:      P1M1&=~(1<<pin);P1M2|=(1<<pin);break;
  60   3                                      case 0xB0:      P3M1&=~(1<<pin);P3M2|=(1<<pin);break;
  61   3                                      default:        break;
  62   3                              }
  63   2                              break;
  64   2                      case GPIO_INPUT_ONLY:
  65   2                              switch(port){
  66   3                                      case 0x80:      P0M1|=(1<<pin);P0M2&=~(1<<pin);break;
  67   3                                      case 0x90:      P1M1|=(1<<pin);P1M2&=~(1<<pin);break;
  68   3                                      case 0xB0:      P3M1|=(1<<pin);P3M2&=~(1<<pin);break;
  69   3                                      default:        break;
  70   3                              }
  71   2                              break;
  72   2                      case GPIO_OPEN_DRAIN:
  73   2                              switch(port){
  74   3                                      case 0x80:      P0M1|=(1<<pin);P0M2|=(1<<pin);break;
  75   3                                      case 0x90:      P1M1|=(1<<pin);P1M2|=(1<<pin);break;
  76   3                                      case 0xB0:      P3M1|=(1<<pin);P3M2|=(1<<pin);break;
  77   3                                      default:        break;
  78   3                              }
  79   2                              break;
  80   2                      default : break;
  81   2              }       
  82   1      }
  83          
  84          uint8_t GPIO_Read(uint8_t port, uint8_t pin)
  85          {
  86   1              GPIO_Init(port,pin,GPIO_INPUT_ONLY);
  87   1              return (port>>pin)&0x01;
  88   1      }
  89          
  90          
  91          
  92          #if ( TIME_ENABLE == 1 )
              void InitUART(void)
              {
                      if ( sBike.bUart == 0 )
                              return ;
                      
                      /* USART configured as follow:
                              - BaudRate = 9600 baud  
                              - Word Length = 8 Bits
                              - One Stop Bit
                              - Odd parity
                              - Receive and transmit enabled
                              - UART Clock disabled
                      */
                      UART1_Init((uint32_t)9600, UART1_WORDLENGTH_8D,UART1_STOPBITS_1, UART1_PARITY_ODD,
                                                 UART1_SYNCMODE_CLOCK_DISABLE, UART1_MODE_RX_ENABLE|UART1_MODE_TX_DISABLE);
C51 COMPILER V9.50a   GPIO                                                                 12/04/2017 00:08:34 PAGE 3   

              
                      /* Enable the UART Receive interrupt: this interrupt is generated when the UART
                      receive data register is not empty */
                      UART1_ITConfig(UART1_IT_RXNE_OR, ENABLE);
              
                      /* Enable UART */
                      UART1_Cmd(ENABLE);
              }
              
              void UartTask(void)
              {   
                      uint16_t uiVol,i;
                      
                      if ( sBike.bUart == 0 )
                              return ;
                      
                      if ( ucUart1Index > 0 && ucUart1Buf[ucUart1Index-1] == '\n' ){
                              if ( ucUart1Index >= 11 && ucUart1Buf[0] == 'T' /*&& ucUart1Buf[1] == 'i' && ucUart1Buf[2] == 'm' && ucU
             -art1Buf[3] == 'e' */) {
                                      RtcTime.RTC_Hours       = (ucUart1Buf[5]-'0')*10 + (ucUart1Buf[6] - '0');
                                      RtcTime.RTC_Minutes = (ucUart1Buf[8]-'0')*10 + (ucUart1Buf[9] - '0');
                                      PCF8563_SetTime(PCF_Format_BIN,&RtcTime);
                              } else if ( ucUart1Index >= 5 && ucUart1Buf[0] == 'C' /*&& ucUart1Buf[1] == 'a' && ucUart1Buf[2] == 'l' 
             -&& ucUart1Buf[3] == 'i' */){
                                      for(i=0;i<0xFF;i++){
                                              if ( GetVolStabed(&uiVol) && (uiVol > 120) ) break;
                                              FEED_DOG();  
                                      }
                                      sBike.uiVoltage         = uiVol;
                                      sBike.siTemperature = GetTemp();
                                      sBike.ucSpeed           = GetSpeed();
              
                                      sConfig.uiVolScale      = (uint32_t)sBike.uiVoltage*1000UL/VOL_CALIBRATIOIN;                                    
                              //      sConfig.TempScale       = (long)sBike.siTemperature*1000UL/TEMP_CALIBRATIOIN;   
                                      sConfig.uiSpeedScale= (uint32_t)sBike.ucSpeed*1000UL/SPEED_CALIBRATIOIN;                                
                                      WriteConfig();
                              }
                              ucUart1Index = 0;
                      }
              }
              #endif 
 147          
 148          void Calibration(void)
 149          {
 150   1              uint8_t i;
 151   1              uint16_t uiVol;
 152   1              
 153   1              //GPIO_Init(GPIOD, GPIO_PIN_1, GPIO_MODE_OUT_OD_HIZ_SLOW);
 154   1      
 155   1              for(i=0;i<32;i++){
 156   2                      //GPIO_WriteLow (GPIOD,GPIO_PIN_1);
 157   2                      Timer1_Delay1ms(1000);
 158   2                      if( GPIO_Read(SPMODE1_PORT      , SPMODE1_PIN) ) break;
 159   2                      //GPIO_WriteHigh (GPIOD,GPIO_PIN_1);
 160   2                      Timer1_Delay1ms(1000);
 161   2                      if( GPIO_Read(SPMODE1_PORT      , SPMODE1_PIN)  == RESET ) break;
 162   2              }
 163   1              if ( i == 32 ){
 164   2                      for(i=0;i<0xFF;i++){
 165   3                              if ( GetVolStabed(&uiVol) && (uiVol > 120) ) break;
 166   3                              FEED_DOG();  
 167   3                      }
C51 COMPILER V9.50a   GPIO                                                                 12/04/2017 00:08:34 PAGE 4   

 168   2                      sBike.uiVoltage         = uiVol;
 169   2                      //sBike.siTemperature= GetTemp();
 170   2                      //sBike.ucSpeed         = GetSpeed();
 171   2      
 172   2                      sConfig.uiVolScale      = (uint32_t)sBike.uiVoltage*1000UL/VOL_CALIBRATIOIN;            //60.00V
 173   2                      //sConfig.TempScale     = (long)sBike.siTemperature*1000UL/TEMP_CALIBRATIOIN;   //25.0C
 174   2                      //sConfig.uiSpeedScale = (uint32_t)sBike.ucSpeed*1000UL/SPEED_CALIBRATIOIN;     //30km/h
 175   2                      //sConfig.ulMile = 0;
 176   2                      WriteConfig();
 177   2              }
 178   1      
 179   1      #if ( TIME_ENABLE == 1 )
                      for(i=0;i<32;i++){
                              GPIO_WriteLow (GPIOD,GPIO_PIN_1);
                              Timer1_Delay1ms(1000);
                              if( GPIO_Read(SPMODE2_PORT      , SPMODE2_PIN) ) break;
                              GPIO_WriteHigh (GPIOD,GPIO_PIN_1);
                              Timer1_Delay1ms(1000);
                              if( GPIO_Read(SPMODE2_PORT      , SPMODE2_PIN)  == RESET ) break;
                      }
                      if ( i == 32 ){
                              sBike.bUart = 1;
                      } else
                              sBike.bUart = 0;
              #endif
 193   1      }
 194          
 195          #define TIMER0_TH0_1MS  0x05
 196          #define TIMER0_TL0_1MS  0x35
 197          #define INC_SYS_TICK()  uiSysTick++
 198          
 199          void Timer0_Init(void)
 200          {
 201   1              //TMOD = 0XFF;
 202   1              clr_TR0;
 203   1              TIMER0_MODE0_ENABLE;                        //Timer 0 and Timer 1 mode configuration
 204   1              clr_T0M;
 205   1          
 206   1              TH0 = TIMER0_TH0_1MS;
 207   1              TL0 = TIMER0_TL0_1MS;
 208   1          
 209   1              set_ET0;                                    //enable Timer0 interrupt
 210   1              set_EA;                                     //enable interrupts
 211   1              
 212   1              set_TR0;                                    //Timer0 run
 213   1      }
 214          
 215          /*********************************************************************************************************
             -***
 216          *    TIMER 0 interrupt subroutine
 217          **********************************************************************************************************
             -**/
 218          void Timer0_ISR (void) interrupt 1          //interrupt address is 0x000B
 219          {
 220   1              clr_TR0;
 221   1          TH0 = TIMER0_TH0_1MS;
 222   1          TL0 = TIMER0_TL0_1MS; 
 223   1              set_TR0;        
 224   1              
 225   1              uiSysTick++;
 226   1              if ( (uiSysTick % 10) == 0)
 227   1                      LRFlashTask();
C51 COMPILER V9.50a   GPIO                                                                 12/04/2017 00:08:34 PAGE 5   

 228   1              
 229   1              ADC_TRIG();
 230   1      }
 231          
 232          void main(void)
 233          {
 234   1              uint8_t i;
 235   1              uint16_t uiTick;
 236   1              uint16_t uiCount=0;
 237   1              uint16_t uiVol=0;
 238   1              uint16_t tick_100ms=0;
 239   1              
 240   1              WDG_Config();
 241   1              Timer0_Init();  
 242   1              HotReset();
 243   1      /*      if ( sBike.bHotReset == 0 ) {
 244   1                      BL55072_Config(1);
 245   1              } else
 246   1                      BL55072_Config(0);
 247   1      */
 248   1              ADC_Init();
 249   1      //      for(i=0;i<32;i++){      GetVol();       /*FEED_DOG(); */ }
 250   1      //      for(i=0;i<16;i++){      GetSpeed();     /*FEED_DOG(); */ }
 251   1      //      for(i=0;i<4;i++) {      GetTemp();      FEED_DOG(); }
 252   1      
 253   1              InitConfig();
 254   1              Calibration();
 255   1              
 256   1      #if ( TIME_ENABLE == 1 )        
                      //sBike.bHasTimer = !PCF8563_Check();
                      sBike.bHasTimer = PCF8563_GetTime(PCF_Format_BIN,&RtcTime);
                      #ifndef DENGGUAN_XUNYING_T
                      InitUART();
                      #endif
              #endif
 263   1      
 264   1      #if ( YXT_ENABLE == 1 )
 265   1              //YXT_Init();  
 266   1      #endif
 267   1        
 268   1              ENABLE_INTERRUPTS();
 269   1              
 270   1              if ( sBike.bHotReset == 0 ) {
 271   2                      while ( Get_SysTick() < PON_ALLON_TIME ) FEED_DOG();
 272   2                      //BL55072_Config(0);
 273   2              }
 274   1              
 275   1              GetVolStabed(&uiVol);
 276   1              sBike.uiVoltage = (uint32_t)uiVol*1000UL/sConfig.uiVolScale;
 277   1              sBike.siTemperature = GetTemp();
*** WARNING C206 IN LINE 277 OF Code\GPIO.C: 'GetTemp': missing function-prototype
 278   1              
 279   1              while(1){
 280   2                      uiTick = Get_SysTick();
 281   2                      
 282   2                      if ( (uiTick >= tick_100ms && (uiTick - tick_100ms) >= 100 ) || \
 283   3                               (uiTick <  tick_100ms && (0xFFFF - tick_100ms + uiTick) >= 100 ) ) {
 284   3                              tick_100ms = uiTick;
 285   3                              uiCount ++;
 286   3                              
 287   3                              if ( (uiCount % 4 ) == 0 ){
 288   4                                      if ( GetVolStabed(&uiVol) ){
C51 COMPILER V9.50a   GPIO                                                                 12/04/2017 00:08:34 PAGE 6   

 289   5                                              sBike.uiVoltage = (uint32_t)uiVol*1000UL/sConfig.uiVolScale;
 290   5                                              sBike.ucBatStatus= GetBatStatus(sBike.uiVoltage);
 291   5                                      }
 292   4                              }
 293   3                              if ( (uiCount % 10) == 0 ){
 294   4                              //      sBike.siTemperature= (long)GetTemp()    *1000UL/sConfig.TempScale;
 295   4                                      sBike.siTemperature= GetTemp();
 296   4                              }
 297   3                      #ifdef LCD8794GCT
                                      //sBike.ucEnergy        = GetBatEnergy(sBike.uiVoltage);
                              #endif
 300   3                      
 301   3                              Light_Task();
 302   3                              MileTask(); 
 303   3                              
 304   3                      #if ( YXT_ENABLE == 1 )
 305   3                              //YXT_Task(&sBike,&sConfig);  
 306   3                      #endif
 307   3                      
 308   3                              SpeedCaltTask();
 309   3                      
 310   3                      #if ( TIME_ENABLE == 1 )        
                                      TimeTask();   
                              #endif
 313   3            
 314   3                      #ifdef LCD_SEG_TEST
                                      if ( ++uiCount >= 100 ) uiCount = 0;
                                      sBike.uiVoltage         = uiCount/10 + uiCount/10*10UL + uiCount/10*100UL + uiCount/10*1000UL;
                                      sBike.siTemperature     = uiCount/10 + uiCount/10*10UL + uiCount/10*100UL;
                                      sBike.ucSpeed           = uiCount/10 + uiCount/10*10;
                                      sBike.ulMile            = uiCount/10 + uiCount/10*10UL + uiCount/10*100UL + uiCount/10*1000UL + uiCount/10*10000U
             -L;
                                      sBike.ucHour            = uiCount/10 + uiCount/10*10;
                                      sBike.ucMinute          = uiCount/10 + uiCount/10*10;
                                      #ifdef LCD8794GCT
                                      //sBike.ucEnergy        = uiCount/10 + uiCount/10*10UL;
                                      #endif
                              #endif
 326   3              
 327   3                              //MenuUpdate(&sBike);
 328   3                              
 329   3                              /* Reload IWDG counter */
 330   3                              FEED_DOG();  
 331   3                      } 
 332   2      
 333   2              #if ( TIME_ENABLE == 1 )
                              #ifndef DENGGUAN_XUNYING_T
                              UartTask();
                              #endif
                      #endif
 338   2              }
 339   1      }
*** WARNING C280 IN LINE 234 OF Code\GPIO.C: 'i': unreferenced local variable
 340          
 341          
 342          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    945    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      10
C51 COMPILER V9.50a   GPIO                                                                 12/04/2017 00:08:34 PAGE 7   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.50a   GPIO                                                                 12/04/2017 14:02:09 PAGE 1   


C51 COMPILER V9.50a, COMPILATION OF MODULE GPIO
OBJECT MODULE PLACED IN .\Output\GPIO.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Code\GPIO.C LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Include) DEFINE(FOS
                    -C_160000) DEBUG OBJECTEXTEND PRINT(.\LST\GPIO.lst) OBJECT(.\Output\GPIO.obj)

line level    source

   1          /*--------------------------------------------------------------------------------------------------------
             --*/
   2          /*                                                                                                        
             - */
   3          /* Copyright(c) 2017 Nuvoton Technology Corp. All rights reserved.                                        
             - */
   4          /*                                                                                                        
             - */
   5          /*--------------------------------------------------------------------------------------------------------
             --*/
   6          
   7          //********************************************************************************************************
             -***
   8          //  Website: http://www.nuvoton.com
   9          //  E-Mail : MicroC-8bit@nuvoton.com
  10          //  Date   : Jan/21/2017
  11          //********************************************************************************************************
             -***
  12          
  13          //********************************************************************************************************
             -***
  14          //  File Function: N76E003 GPIO demo code
  15          //********************************************************************************************************
             -***
  16          #include <stdlib.h>
  17          #include <string.h>
  18          
  19          #include "N76E003.h"
  20          #include "SFR_Macro.h"
  21          #include "Function_define.h"
  22          #include "Common.h"
  23          #include "Delay.h"
  24          
  25          #include "adc.h"
  26          #include "bl55072.h"
  27          #include "display.h"
  28          #include "bike.h"
  29          #include "YXT.h"
  30          
  31          
  32          /**
  33            * @brief  Configures the IWDG to generate a Reset if it is not refreshed at the
  34            *         correct time. 
  35            * @param  None
  36            * @retval None
  37            */
  38          static void WDG_Config(void)
  39          {
  40   1      }
  41          
  42          //enum GPIO_PORT = {GPIO0,GPIO1,GPIO2,GPIO3};
  43          //enum GPIO_PIN  = {PIN0,PIN1,PIN2,PIN3,PIN4,PIN5,PIN6,PIN7};
  44          
  45          void GPIO_Init(uint8_t port, uint8_t pin, uint8_t mode)
C51 COMPILER V9.50a   GPIO                                                                 12/04/2017 14:02:09 PAGE 2   

  46          {
  47   1              if ( pin > 7 ) return;
  48   1              switch ( mode ){
  49   2              case GPIO_QUASI:
  50   2                      switch(port){
  51   3                              case 0x80:      P0M1&=~(1<<pin);P0M2&=~(1<<pin);break;
  52   3                              case 0x90:      P1M1&=~(1<<pin);P1M2&=~(1<<pin);break;
  53   3                              case 0xB0:      if (pin == 0) 
  54   3                                                      P3M1&=~(0x01);  P3M2&=~(0x01);break;
  55   3                              default:        break;
  56   3                      }
  57   2                      break;
  58   2              case GPIO_PUSH_PULL:
  59   2                      switch(port){
  60   3                              case 0x80:      P0M1&=~(1<<pin);P0M2|=(1<<pin);break;
  61   3                              case 0x90:      P1M1&=~(1<<pin);P1M2|=(1<<pin);break;
  62   3                              case 0xB0:      if (pin == 0) 
  63   3                                                      P3M1&=~(0x01);  P3M2|=(0x01);break;
  64   3                              default:        break;
  65   3                      }
  66   2                      break;
  67   2              case GPIO_INPUT_ONLY:
  68   2                      switch(port){
  69   3                              case 0x80:      P0M1|=(1<<pin);P0M2&=~(1<<pin);break;
  70   3                              case 0x90:      P1M1|=(1<<pin);P1M2&=~(1<<pin);break;
  71   3                              case 0xB0:      if (pin == 0) 
  72   3                                                      P3M1|=(0x01);   P3M2&=~(0x01);break;
  73   3                              default:        break;
  74   3                      }
  75   2                      break;
  76   2              case GPIO_OPEN_DRAIN:
  77   2                      switch(port){
  78   3                              case 0x80:      P0M1|=(1<<pin);P0M2|=(1<<pin);break;
  79   3                              case 0x90:      P1M1|=(1<<pin);P1M2|=(1<<pin);break;
  80   3                              case 0xB0:      if (pin == 0) 
  81   3                                                      P3M1|=(0x01);   P3M2|=(0x01);break;
  82   3                              default:        break;
  83   3                      }
  84   2                      break;
  85   2              default : break;
  86   2              }       
  87   1      }
  88          
  89          uint8_t GPIO_Read(uint8_t port, uint8_t pin)
  90          {
  91   1              GPIO_Init(port,pin,GPIO_INPUT_ONLY);
  92   1              return (port>>pin)&0x01;
  93   1      }
  94          
  95          #if ( TIME_ENABLE == 1 )
              void InitUART(void)
              {
                      if ( sBike.bUart == 0 )
                              return ;
                      
                      /* USART configured as follow:
                              - BaudRate = 9600 baud  
                              - Word Length = 8 Bits
                              - One Stop Bit
                              - Odd parity
                              - Receive and transmit enabled
                              - UART Clock disabled
C51 COMPILER V9.50a   GPIO                                                                 12/04/2017 14:02:09 PAGE 3   

                      */
                      UART1_Init((uint32_t)9600, UART1_WORDLENGTH_8D,UART1_STOPBITS_1, UART1_PARITY_ODD,
                                                 UART1_SYNCMODE_CLOCK_DISABLE, UART1_MODE_RX_ENABLE|UART1_MODE_TX_DISABLE);
              
                      /* Enable the UART Receive interrupt: this interrupt is generated when the UART
                      receive data register is not empty */
                      UART1_ITConfig(UART1_IT_RXNE_OR, ENABLE);
              
                      /* Enable UART */
                      UART1_Cmd(ENABLE);
              }
              
              void UartTask(void)
              {   
                      uint16_t uiVol,i;
                      
                      if ( sBike.bUart == 0 )
                              return ;
                      
                      if ( ucUart1Index > 0 && ucUart1Buf[ucUart1Index-1] == '\n' ){
                              if ( ucUart1Index >= 11 && ucUart1Buf[0] == 'T' /*&& ucUart1Buf[1] == 'i' && ucUart1Buf[2] == 'm' && ucU
             -art1Buf[3] == 'e' */) {
                                      RtcTime.RTC_Hours       = (ucUart1Buf[5]-'0')*10 + (ucUart1Buf[6] - '0');
                                      RtcTime.RTC_Minutes = (ucUart1Buf[8]-'0')*10 + (ucUart1Buf[9] - '0');
                                      PCF8563_SetTime(PCF_Format_BIN,&RtcTime);
                              } else if ( ucUart1Index >= 5 && ucUart1Buf[0] == 'C' /*&& ucUart1Buf[1] == 'a' && ucUart1Buf[2] == 'l' 
             -&& ucUart1Buf[3] == 'i' */){
                                      for(i=0;i<0xFF;i++){
                                              if ( GetVolStabed(&uiVol) && (uiVol > 120) ) break;
                                              FEED_DOG();  
                                      }
                                      sBike.uiVoltage         = uiVol;
                                      sBike.siTemperature = GetTemp();
                                      sBike.ucSpeed           = GetSpeed();
              
                                      sConfig.uiVolScale      = (uint32_t)sBike.uiVoltage*1000UL/VOL_CALIBRATIOIN;                                    
                              //      sConfig.TempScale       = (long)sBike.siTemperature*1000UL/TEMP_CALIBRATIOIN;   
                                      sConfig.uiSpeedScale= (uint32_t)sBike.ucSpeed*1000UL/SPEED_CALIBRATIOIN;                                
                                      WriteConfig();
                              }
                              ucUart1Index = 0;
                      }
              }
              #endif 
 150          
 151          void Calibration(void)
 152          {
 153   1              uint8_t i;
 154   1              uint16_t uiVol;
 155   1              
 156   1              //GPIO_Init(GPIOD, GPIO_PIN_1, GPIO_MODE_OUT_OD_HIZ_SLOW);
 157   1      
 158   1              for(i=0;i<32;i++){
 159   2                      //GPIO_WriteLow (GPIOD,GPIO_PIN_1);
 160   2                      Timer1_Delay1ms(1000);
 161   2                      if( GPIO_Read(SPMODE1_PORT      , SPMODE1_PIN) ) break;
 162   2                      //GPIO_WriteHigh (GPIOD,GPIO_PIN_1);
 163   2                      Timer1_Delay1ms(1000);
 164   2                      if( GPIO_Read(SPMODE1_PORT      , SPMODE1_PIN)  == RESET ) break;
 165   2              }
 166   1              if ( i == 32 ){
 167   2                      for(i=0;i<0xFF;i++){
C51 COMPILER V9.50a   GPIO                                                                 12/04/2017 14:02:09 PAGE 4   

 168   3                              if ( GetVolStabed(&uiVol) && (uiVol > 120) ) break;
 169   3                              FEED_DOG();  
 170   3                      }
 171   2                      sBike.uiVoltage         = uiVol;
 172   2                      //sBike.siTemperature= GetTemp();
 173   2                      //sBike.ucSpeed         = GetSpeed();
 174   2      
 175   2                      sConfig.uiVolScale      = (uint32_t)sBike.uiVoltage*1000UL/VOL_CALIBRATIOIN;            //60.00V
 176   2                      //sConfig.TempScale     = (long)sBike.siTemperature*1000UL/TEMP_CALIBRATIOIN;   //25.0C
 177   2                      //sConfig.uiSpeedScale = (uint32_t)sBike.ucSpeed*1000UL/SPEED_CALIBRATIOIN;     //30km/h
 178   2                      //sConfig.ulMile = 0;
 179   2                      WriteConfig();
 180   2              }
 181   1      
 182   1      #if ( TIME_ENABLE == 1 )
                      for(i=0;i<32;i++){
                              GPIO_WriteLow (GPIOD,GPIO_PIN_1);
                              Timer1_Delay1ms(1000);
                              if( GPIO_Read(SPMODE2_PORT      , SPMODE2_PIN) ) break;
                              GPIO_WriteHigh (GPIOD,GPIO_PIN_1);
                              Timer1_Delay1ms(1000);
                              if( GPIO_Read(SPMODE2_PORT      , SPMODE2_PIN)  == RESET ) break;
                      }
                      if ( i == 32 ){
                              sBike.bUart = 1;
                      } else
                              sBike.bUart = 0;
              #endif
 196   1      }
 197          
 198          #define TIMER0_TH0_1MS  0x05
 199          #define TIMER0_TL0_1MS  0x35
 200          #define INC_SYS_TICK()  uiSysTick++
 201          
 202          void Timer0_Init(void)
 203          {
 204   1              //TMOD = 0XFF;
 205   1              clr_TR0;
 206   1              TIMER0_MODE0_ENABLE;                        //Timer 0 and Timer 1 mode configuration
 207   1              clr_T0M;
 208   1          
 209   1              TH0 = TIMER0_TH0_1MS;
 210   1              TL0 = TIMER0_TL0_1MS;
 211   1          
 212   1              set_ET0;                                    //enable Timer0 interrupt
 213   1              set_EA;                                     //enable interrupts
 214   1              
 215   1              set_TR0;                                    //Timer0 run
 216   1      }
 217          
 218          /*********************************************************************************************************
             -***
 219          *    TIMER 0 interrupt subroutine
 220          **********************************************************************************************************
             -**/
 221          void Timer0_ISR (void) interrupt 1          //interrupt address is 0x000B
 222          {
 223   1              clr_TR0;
 224   1          TH0 = TIMER0_TH0_1MS;
 225   1          TL0 = TIMER0_TL0_1MS; 
 226   1              set_TR0;        
 227   1              
C51 COMPILER V9.50a   GPIO                                                                 12/04/2017 14:02:09 PAGE 5   

 228   1              uiSysTick++;
 229   1              if ( (uiSysTick % 10) == 0)
 230   1                      LRFlashTask();
 231   1              
 232   1              ADC_TRIG();
 233   1      }
 234          
 235          void main(void)
 236          {
 237   1              uint8_t i;
 238   1              uint16_t uiTick;
 239   1              uint16_t uiCount=0;
 240   1              uint16_t uiVol=0;
 241   1              uint16_t tick_100ms=0;
 242   1              
 243   1              WDG_Config();
 244   1              Timer0_Init();  
 245   1              HotReset();
 246   1      /*      if ( sBike.bHotReset == 0 ) {
 247   1                      BL55072_Config(1);
 248   1              } else
 249   1                      BL55072_Config(0);
 250   1      */
 251   1              ADC_Init();
 252   1      //      for(i=0;i<32;i++){      GetVol();       /*FEED_DOG(); */ }
 253   1      //      for(i=0;i<16;i++){      GetSpeed();     /*FEED_DOG(); */ }
 254   1      //      for(i=0;i<4;i++) {      GetTemp();      FEED_DOG(); }
 255   1      
 256   1              InitConfig();
 257   1              Calibration();
 258   1              
 259   1      #if ( TIME_ENABLE == 1 )        
                      //sBike.bHasTimer = !PCF8563_Check();
                      sBike.bHasTimer = PCF8563_GetTime(PCF_Format_BIN,&RtcTime);
                      #ifndef DENGGUAN_XUNYING_T
                      InitUART();
                      #endif
              #endif
 266   1      
 267   1      #if ( YXT_ENABLE == 1 )
 268   1              YXT_Init();  
 269   1      #endif
 270   1        
 271   1              ENABLE_INTERRUPTS();
 272   1              
 273   1              if ( sBike.bHotReset == 0 ) {
 274   2                      while ( Get_SysTick() < PON_ALLON_TIME ) FEED_DOG();
 275   2                      //BL55072_Config(0);
 276   2              }
 277   1              
 278   1              GetVolStabed(&uiVol);
 279   1              sBike.uiVoltage = (uint32_t)uiVol*1000UL/sConfig.uiVolScale;
 280   1              sBike.siTemperature = GetTemp();
*** WARNING C206 IN LINE 280 OF Code\GPIO.C: 'GetTemp': missing function-prototype
 281   1              
 282   1              while(1){
 283   2                      uiTick = Get_SysTick();
 284   2                      
 285   2                      if ( (uiTick >= tick_100ms && (uiTick - tick_100ms) >= 100 ) || \
 286   3                               (uiTick <  tick_100ms && (0xFFFF - tick_100ms + uiTick) >= 100 ) ) {
 287   3                              tick_100ms = uiTick;
 288   3                              uiCount ++;
C51 COMPILER V9.50a   GPIO                                                                 12/04/2017 14:02:09 PAGE 6   

 289   3                              
 290   3                              if ( (uiCount % 4 ) == 0 ){
 291   4                                      if ( GetVolStabed(&uiVol) ){
 292   5                                              sBike.uiVoltage = (uint32_t)uiVol*1000UL/sConfig.uiVolScale;
 293   5                                              sBike.ucBatStatus= GetBatStatus(sBike.uiVoltage);
 294   5                                      }
 295   4                              }
 296   3                              if ( (uiCount % 10) == 0 ){
 297   4                              //      sBike.siTemperature= (long)GetTemp()    *1000UL/sConfig.TempScale;
 298   4                                      sBike.siTemperature= GetTemp();
 299   4                              }
 300   3                      #ifdef LCD8794GCT
                                      //sBike.ucEnergy        = GetBatEnergy(sBike.uiVoltage);
                              #endif
 303   3                      
 304   3                              Light_Task();
 305   3                              MileTask(); 
 306   3                              
 307   3                      #if ( YXT_ENABLE == 1 )
 308   3                              YXT_Task(&sBike,&sConfig);  
 309   3                      #endif
 310   3                      
 311   3                              SpeedCaltTask();
 312   3                      
 313   3                      #if ( TIME_ENABLE == 1 )        
                                      TimeTask();   
                              #endif
 316   3            
 317   3                      #ifdef LCD_SEG_TEST
                                      if ( ++uiCount >= 100 ) uiCount = 0;
                                      sBike.uiVoltage         = uiCount/10 + uiCount/10*10UL + uiCount/10*100UL + uiCount/10*1000UL;
                                      sBike.siTemperature     = uiCount/10 + uiCount/10*10UL + uiCount/10*100UL;
                                      sBike.ucSpeed           = uiCount/10 + uiCount/10*10;
                                      sBike.ulMile            = uiCount/10 + uiCount/10*10UL + uiCount/10*100UL + uiCount/10*1000UL + uiCount/10*10000U
             -L;
                                      sBike.ucHour            = uiCount/10 + uiCount/10*10;
                                      sBike.ucMinute          = uiCount/10 + uiCount/10*10;
                                      #ifdef LCD8794GCT
                                      //sBike.ucEnergy        = uiCount/10 + uiCount/10*10UL;
                                      #endif
                              #endif
 329   3              
 330   3                              //MenuUpdate(&sBike);
 331   3                              
 332   3                              /* Reload IWDG counter */
 333   3                              FEED_DOG();  
 334   3                      } 
 335   2      
 336   2              #if ( TIME_ENABLE == 1 )
                              #ifndef DENGGUAN_XUNYING_T
                              UartTask();
                              #endif
                      #endif
 341   2              }
 342   1      }
*** WARNING C280 IN LINE 237 OF Code\GPIO.C: 'i': unreferenced local variable
 343          
 344          
 345          


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.50a   GPIO                                                                 12/04/2017 14:02:09 PAGE 7   

   CODE SIZE        =    942    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)

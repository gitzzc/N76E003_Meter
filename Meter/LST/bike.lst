C51 COMPILER V9.50a   BIKE                                                                 11/23/2017 17:08:04 PAGE 1   


C51 COMPILER V9.50a, COMPILATION OF MODULE BIKE
OBJECT MODULE PLACED IN .\Output\bike.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Code\bike.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Include) DEFINE(FOSC_1600
                    -00) DEBUG OBJECTEXTEND PRINT(.\LST\bike.lst) OBJECT(.\Output\bike.obj)

line level    source

   1          /**
   2            ******************************************************************************
   3            * @file    bike.c
   4            * @author  
   5            * @version V2.2.0
   6            * @date    30-September-2014
   7            * @brief   Main Interrupt Service Routines.
   8            *          This file provides template for all peripherals interrupt service 
   9            *          routine.
  10             ******************************************************************************
  11            * @attention
  12            *
  13            *
  14            ******************************************************************************
  15            */ 
  16            
  17          /* Includes ------------------------------------------------------------------*/
  18          
  19          #include "bl55072.h"
  20          #include "display.h"
*** ERROR C320 IN LINE 267 OF Code\bike.h: "Please select a release!!!"
*** ERROR C320 IN LINE 273 OF Code\bike.h: "Not defined LCD_TYPE"
*** ERROR C141 IN LINE 309 OF Code\bike.h: syntax error near 'uint8_t'
*** ERROR C129 IN LINE 309 OF Code\bike.h: missing ';' before 'bLFlashType'
  21          #include "pcf8563.h"
*** WARNING C318 IN LINE 21 OF Code\bike.c: can't open file 'pcf8563.h'
  22          #include "bike.h"
  23          #include "YXT.h"
  24          
  25          /* Private typedef -----------------------------------------------------------*/
  26          /* Private define ------------------------------------------------------------*/
  27          /* Private macro -------------------------------------------------------------*/
  28          /* Private variables ---------------------------------------------------------*/
  29          #ifdef JINPENG_4860
              const uint16_t uiBatStatus48[8] = {420,426,432,439,445,451,457,464};
              const uint16_t uiBatStatus60[8] = {520,528,536,542,550,558,566,574};
              const uint16_t uiBatStatus72[8] = {0};
              #elif defined JINPENG_6072
              const uint16_t uiBatStatus48[8] = {0};
              const uint16_t uiBatStatus60[8] = {480,493,506,519,532,545,558,570};
              const uint16_t uiBatStatus72[8] = {550,569,589,608,628,647,667,686};
              #elif defined LCD6040
              const uint16_t uiBatStatus48[] = {425,432,444,456,468};
              const uint16_t uiBatStatus60[] = {525,537,553,566,578};
              const uint16_t uiBatStatus72[] = {630,641,661,681,701};
              #else
  42          const uint16_t uiBatStatus48[8] = {420,427,435,444,453,462,471,481};
  43          const uint16_t uiBatStatus60[8] = {520,531,544,556,568,577,587,595};
  44          const uint16_t uiBatStatus72[8] = {630,642,653,664,675,687,700,715};
  45          #endif
  46          
  47          BIKE_STATUS sBike;
  48          __no_init BIKE_CONFIG sConfig;
  49          volatile uint16_t  uiSysTick = 0;
C51 COMPILER V9.50a   BIKE                                                                 11/23/2017 17:08:04 PAGE 2   

  50          uint16_t uiSpeedBuf[16];
  51          uint16_t uiVolBuf[28];
  52          uint16_t uiTempBuf[4];
  53          
  54          #if ( TIME_ENABLE == 1 )
              uint8_t ucUart1Buf[16];
              uint8_t ucUart1Index=0;
              #endif
  58          /* Private function prototypes -----------------------------------------------*/
  59          /* Private functions ---------------------------------------------------------*/
  60          /* Public functions ----------------------------------------------------------*/
  61          
  62          /*----------------------------------------------------------*/
  63          
  64          int GetTemp(void)
  65          {
  66                  static uint8_t ucIndex = 0;
  67                  int32_t slTemp;
  68                  uint8_t i;
  69          
  70                  //GPIO_Init(GPIOD, GPIO_PIN_6, GPIO_MODE_IN_FL_NO_IT);  //Temp
  71                  //ADC1_DeInit();  
  72                  ADC1_Init(ADC1_CONVERSIONMODE_CONTINUOUS, ADC1_CHANNEL_6, ADC1_PRESSEL_FCPU_D2, \
  73                                          ADC1_EXTTRIG_TIM, DISABLE, ADC1_ALIGN_RIGHT, ADC1_SCHMITTTRIG_CHANNEL6 ,\
  74                                          DISABLE);
  75                  ADC1_Cmd(ENABLE);
  76                  Delay(1000);
  77                  ADC1_StartConversion(); 
  78                  while ( ADC1_GetFlagStatus(ADC1_FLAG_EOC) == RESET );  
  79                  slTemp = ADC1_GetConversionValue();
  80                  ADC1_Cmd(DISABLE);
  81            
  82                  uiTempBuf[ucIndex++] = slTemp;
  83                  if ( ucIndex >= ContainOf(uiTempBuf) )
  84                          ucIndex = 0;
  85                  for(i=0,slTemp=0;i<ContainOf(uiTempBuf);i++)
  86                          slTemp += uiTempBuf[i];
  87                  slTemp /= ContainOf(uiTempBuf);
  88          
  89                  //slTemp = 470UL*1024/(1024-slTemp)-470;
  90                  //slTemp = NTCtoTemp(slTemp)/10;
  91                  //slTemp = ((3600- (long)slTemp * 2905/1024)/10);
  92          
  93                  slTemp = 10000*1024UL/(1024-slTemp)-10000;
  94                  slTemp = NTCtoTemp(slTemp);
  95                  if ( slTemp > 999  ) slTemp =  999;
  96                  if ( slTemp < -999 ) slTemp = -999;
  97                  
  98                  return slTemp;
  99          }
 100          #if 0
              uint16_t GetVol(void)
              {
                      static uint8_t ucIndex = 0;
                      uint16_t uiVol;
                      uint8_t i;
              
                      GPIO_Init(GPIOC, GPIO_PIN_4, GPIO_MODE_IN_FL_NO_IT);  //B+  
                      ADC1_DeInit();  
                      ADC1_Init(ADC1_CONVERSIONMODE_CONTINUOUS, ADC1_CHANNEL_2, ADC1_PRESSEL_FCPU_D2, \
                                              ADC1_EXTTRIG_TIM, DISABLE, ADC1_ALIGN_RIGHT, ADC1_SCHMITTTRIG_CHANNEL2,\
                                              DISABLE);
C51 COMPILER V9.50a   BIKE                                                                 11/23/2017 17:08:04 PAGE 3   

                      ADC1_Cmd(ENABLE);
                      Delay(5000);  
                      ADC1_StartConversion(); 
                      while ( ADC1_GetFlagStatus(ADC1_FLAG_EOC) == RESET );  
                      uiVol = ADC1_GetConversionValue();
                      ADC1_Cmd(DISABLE);
              
                      uiVolBuf[ucIndex++] = uiVol;
                      if ( ucIndex >= ContainOf(uiVolBuf) )
                              ucIndex = 0;
                      for(i=0,uiVol=0;i<ContainOf(uiVolBuf);i++)
                              uiVol += uiVolBuf[i];
                      uiVol /= ContainOf(uiVolBuf);
                      uiVol = (uint32_t)uiVol*1050/1024 ;
                      
                      return uiVol;
              }
              #else
 130          uint8_t GetVolStabed(uint16_t* uiVol)
 131          {
 132                  uint32_t ulMid;
 133                  uint16_t uiBuf[32];
 134                  uint8_t i;
 135                  
 136                  //GPIO_Init(GPIOC, GPIO_PIN_4, GPIO_MODE_IN_FL_NO_IT);  //B+  
 137                  //ADC1_DeInit();  
 138                  ADC1_Init(ADC1_CONVERSIONMODE_CONTINUOUS, ADC1_CHANNEL_2, ADC1_PRESSEL_FCPU_D2, \
 139                                          ADC1_EXTTRIG_TIM, DISABLE, ADC1_ALIGN_RIGHT, ADC1_SCHMITTTRIG_CHANNEL2,\
 140                                          DISABLE);
 141          
 142                  ADC1_Cmd(ENABLE);
 143                  for(i=0;i<32;i++){
 144                          Delay(500);  
 145                          ADC1_StartConversion(); 
 146                          while ( ADC1_GetFlagStatus(ADC1_FLAG_EOC) == RESET );  
 147                          uiBuf[i] = ADC1_GetConversionValue();
 148                  }
 149                  ADC1_Cmd(DISABLE);
 150                  
 151                  *uiVol = (uint32_t)uiBuf[0]*1050UL/1024UL;
 152          
 153                  for(i=0,ulMid=0;i<32;i++)       ulMid += uiBuf[i];
 154                  ulMid /= 32;
 155                  for( i=0;i<32;i++){
 156                          if ( ulMid > 5 && ((ulMid *100 / uiBuf[i]) > 101 ||  (ulMid *100 / uiBuf[i]) < 99) )
 157                                  return 0;
 158                  }
 159                  
 160                  return 1;
 161          }
 162          
 163          #endif
 164          
 165          #if ( PCB_VER == 0013 )
              uint8_t GetSpeedAdj(void)
              {
                      static uint8_t ucIndex = 0;
                      uint16_t uiAdj;
                      uint8_t i;
              
                      ADC1_DeInit();  
                      ADC1_Init(      ADC1_CONVERSIONMODE_CONTINUOUS, SPEEDV_ADJ_CH, ADC1_PRESSEL_FCPU_D2,\
C51 COMPILER V9.50a   BIKE                                                                 11/23/2017 17:08:04 PAGE 4   

                                              ADC1_EXTTRIG_TIM, DISABLE, ADC1_ALIGN_RIGHT, SPEEDV_ADJ_SCH,DISABLE);
              
                      ADC1_Cmd(ENABLE);
                      Delay(1000);  
                      ADC1_StartConversion(); 
                      while ( ADC1_GetFlagStatus(ADC1_FLAG_EOC) == RESET );  
                      uiAdj = ADC1_GetConversionValue();
                      ADC1_Cmd(DISABLE);
                      
                      uiSpeedBuf[ucIndex++] = uiAdj;
                      if ( ucIndex >= ContainOf(uiSpeedBuf) )
                              ucIndex = 0;
              
                      for(i=0,uiAdj=0;i<ContainOf(uiSpeedBuf);i++)
                              uiAdj += uiSpeedBuf[i];
                      uiAdj /= ContainOf(uiSpeedBuf);
                      
                      if ( uiAdj > 99 )
                              uiAdj = 99;
                      
                return uiAdj;
              }
              #endif
 197          
 198          uint8_t GetSpeed(void)
 199          {
 200                  static uint8_t ucIndex = 0;
 201                  uint16_t uiSpeed;
 202                  uint8_t i;
 203          
 204                  //GPIO_Init(GPIOD, GPIO_PIN_2, GPIO_MODE_IN_FL_NO_IT);
 205                  //ADC1_DeInit();  
 206                  ADC1_Init(ADC1_CONVERSIONMODE_CONTINUOUS, SPEEDV_ADC_CH, ADC1_PRESSEL_FCPU_D2, \
 207                                  ADC1_EXTTRIG_TIM, DISABLE, ADC1_ALIGN_RIGHT, SPEEDV_ADC_SCH,\
 208                                  DISABLE);
 209          
 210                  ADC1_Cmd(ENABLE);
 211                  Delay(1000);  
 212                  ADC1_StartConversion(); 
 213                  while ( ADC1_GetFlagStatus(ADC1_FLAG_EOC) == RESET );  
 214                  uiSpeed = ADC1_GetConversionValue();
 215                  ADC1_Cmd(DISABLE);
 216                  
 217                  uiSpeedBuf[ucIndex++] = uiSpeed;
 218                  if ( ucIndex >= ContainOf(uiSpeedBuf) )
 219                          ucIndex = 0;
 220          
 221                  for(i=0,uiSpeed=0;i<ContainOf(uiSpeedBuf);i++)
 222                          uiSpeed += uiSpeedBuf[i];
 223                  uiSpeed /= ContainOf(uiSpeedBuf);
 224                  
 225                  if ( sConfig.uiSysVoltage               == 48 ){
 226                          uiSpeed = SPEED_CALC_48V((uint32_t)uiSpeed);
 227                  } else if ( sConfig.uiSysVoltage== 60 ) {
 228                          uiSpeed = SPEED_CALC_60V((uint32_t)uiSpeed);
 229                  } else if ( sConfig.uiSysVoltage== 72 ) {
 230                          uiSpeed = SPEED_CALC_72V((uint32_t)uiSpeed);
 231                  }
 232                  if ( uiSpeed > 99 )
 233                          uiSpeed = 99;
 234                  
 235            return uiSpeed;
C51 COMPILER V9.50a   BIKE                                                                 11/23/2017 17:08:04 PAGE 5   

 236          }
 237          
 238          /*----------------------------------------------------------*/
 239          
 240          
 241          uint16_t Get_SysTick(void)
 242          {
 243                  uint16_t uiTick;
 244                  
 245                  disableInterrupts();
 246                  uiTick = uiSysTick;
 247                  enableInterrupts();
 248                  
 249                  return uiTick;
 250          }
 251          
 252          uint16_t Get_ElapseTick(uint16_t uiPreTick)
 253          {
 254                  uint16_t uiTick = Get_SysTick();
 255          
 256                  if ( uiTick >= uiPreTick )      
 257                          return (uiTick - uiPreTick); 
 258                  else 
 259                          return (0xFFFF - uiPreTick + uiTick);
 260          }
 261          
 262          const int32_t NTC_B3450[29][2] = 
 263          {
 264                  251783, -400,   184546, -350,   137003, -300,   102936, -250,   78219,  -200,
 265                  60072,  -150,   46601,  -100,   36495,  -50,    28837,  0,              22980,  50,
 266                  18460,  100,    14942,  150,    12182,  200,    10000,  250,    8263,   300,
 267                  6869,   350,    5745,   400,    4832,   450,    4085,   500,    3472,   550,
 268                  2965,   600,    2544,   650,    2193,   700,    1898,   750,    1649,   800,
 269                  1439,   850,    1260,   900,    1108,   950,    977,    1000
 270          };
 271          
 272          int32_t NTCtoTemp(int32_t ntc)
 273          {
 274                  uint8_t i,j;
 275          
 276                  if ( ntc > NTC_B3450[0][0] ){
 277                          return NTC_B3450[0][1];
 278                  } else {
 279                          for(i=0;i<sizeof(NTC_B3450)/sizeof(NTC_B3450[0][0])/2-1;i++){
 280                                  if ( ntc <= NTC_B3450[i][0] && ntc > NTC_B3450[i+1][0] )
 281                                          break;
 282                          }
 283                          if ( i == sizeof(NTC_B3450)/sizeof(NTC_B3450[0][0])/2-1 ){
 284                                  return NTC_B3450[28][1];
 285                          } else {
 286                                  for(j=0;j<50;j++){
 287                                          if ( NTC_B3450[i][0] - (j*(NTC_B3450[i][0] - NTC_B3450[i+1][0])/50) <= ntc )
 288                                                  return NTC_B3450[i][1] + j;
 289                                  }
 290                                  return NTC_B3450[i+1][1];
 291                          }
 292                  }
 293          }
 294          
 295          void HotReset(void)
 296          {
 297                  if (sConfig.ucBike[0] == 'b' &&
C51 COMPILER V9.50a   BIKE                                                                 11/23/2017 17:08:04 PAGE 6   

 298                  //      sConfig.ucBike[1] == 'i' && 
 299                  //      sConfig.ucBike[2] == 'k' && 
 300                          sConfig.ucBike[3] == 'e' ){
 301                          sBike.bHotReset = 1;
 302                  } else {
 303                          sBike.bHotReset = 0;
 304                  }
 305          }
 306          
 307          void WriteConfig(void)
 308          {
 309                  uint8_t *cbuf = (uint8_t *)&sConfig;
 310                  uint8_t i;
 311          
 312                  sConfig.ucBike[0] = 'b';
 313                  sConfig.ucBike[1] = 'i';
 314                  sConfig.ucBike[2] = 'k';
 315                  sConfig.ucBike[3] = 'e';
 316                  for(sConfig.ucSum=0,i=0;i<sizeof(BIKE_CONFIG)-1;i++)
 317                          sConfig.ucSum += cbuf[i];
 318                          
 319                  for(i=0;i<sizeof(BIKE_CONFIG);i++)
 320                          FLASH_ProgramByte(0x4000+i, cbuf[i]);
 321          }
 322          
 323          void InitConfig(void)
 324          {
 325                  uint8_t *cbuf = (uint8_t *)&sConfig;
 326                  uint8_t i,sum;
 327          
 328                  for(i=0;i<sizeof(BIKE_CONFIG);i++)
 329                          cbuf[i] = FLASH_ReadByte(0x4000 + i);
 330          
 331                  for(sum=0,i=0;i<sizeof(BIKE_CONFIG)-1;i++)
 332                          sum += cbuf[i];
 333                          
 334                  if (sConfig.ucBike[0] != 'b' || 
 335                          //sConfig.ucBike[1] != 'i' || 
 336                          //sConfig.ucBike[2] != 'k' || 
 337                          //sConfig.ucBike[3] != 'e' || 
 338                          sum != sConfig.ucSum ){
 339                          sConfig.uiSysVoltage    = 60;
 340                          sConfig.uiVolScale      = 1000;
 341                          sConfig.uiTempScale     = 1000;
 342                          sConfig.uiSpeedScale    = 1000;
 343                          sConfig.uiYXT_SpeedScale= 1000;
 344          #ifdef SINGLE_TRIP
                              sConfig.uiSingleTrip    = 1;
              #else
 347                          sConfig.uiSingleTrip    = 0;
 348          #endif
 349                          sConfig.ulMile                  = 0;
 350                  }
 351          
 352                  sBike.ulMile = sConfig.ulMile;
 353          #if ( TIME_ENABLE == 1 )
                      sBike.bHasTimer = 0;
              #endif
 356                  sBike.ulFMile = 0;
 357                  sBike.ucSpeedMode = 0;
 358                  sBike.bYXTERR = 1;
 359          }
C51 COMPILER V9.50a   BIKE                                                                 11/23/2017 17:08:04 PAGE 7   

 360          
 361          uint8_t GetBatStatus(uint16_t uiVol)
 362          {
 363                  uint8_t i;
 364                  const uint16_t *uiBatStatus;
 365          
 366                  switch ( sConfig.uiSysVoltage ){
 367                  case 48:uiBatStatus = uiBatStatus48;break;
 368                  case 60:uiBatStatus = uiBatStatus60;break;
 369                  case 72:uiBatStatus = uiBatStatus72;break;
 370                  default:uiBatStatus = uiBatStatus60;break;
 371                  }
 372          
 373                  for(i=0;i<ContainOf(uiBatStatus60);i++)
 374                          if ( uiVol < uiBatStatus[i] ) break;
 375                  return i;
 376          }
 377          
 378          #if 0
              #ifdef LCD8794GCT
              
              const uint16_t BatEnergy48[8] = {420,490};
              const uint16_t BatEnergy60[8] = {520,620};
              const uint16_t BatEnergy72[8] = {630,740};
              
              uint8_t GetBatEnergy(uint16_t uiVol)
              {
                      uint16_t uiEnergy ;
                      const uint16_t* BatEnergy;
                      
                      switch ( sConfig.uiSysVoltage ){
                      case 48:BatEnergy = BatEnergy48;break;
                      case 60:BatEnergy = BatEnergy60;break;
                      case 72:BatEnergy = BatEnergy72;break;
                      default:BatEnergy = BatEnergy60;break;
                      }
              
                      if ( sBike.uiVoltage <= BatEnergy[0] ) uiEnergy = 0;
                      else if ( sBike.uiVoltage >= BatEnergy[1] ) uiEnergy = 100;
                      else {
                              uiEnergy = (sBike.uiVoltage - BatEnergy[0])*100/(BatEnergy[1] - BatEnergy[0]);
                      }
                      return uiEnergy;
              }
              #endif
              #endif
 406          
 407          
 408          
 409          void LRFlashTask(void)
 410          {
 411                  static uint8_t ucLeftOn=0       ,ucLeftOff=0;
 412                  static uint8_t ucRightOn=0      ,ucRightOff=0;
 413                  static uint8_t ucLeftCount=0,ucRightCount=0;
 414          
 415                  if ( READ_TURN_LEFT() ){        //ON
 416                  ucLeftOff = 0;
 417                  if ( ucLeftOn ++ > 10 ){                //200ms ÂË²¨
 418                      if ( ucLeftOn > 100 ){
 419                              ucLeftOn = 101;
 420                          sBike.bLFlashType = 0;
 421                      }
C51 COMPILER V9.50a   BIKE                                                                 11/23/2017 17:08:04 PAGE 8   

 422                          if ( ucLeftCount < 0xFF-50 ){
 423                              ucLeftCount++;
 424                      }
 425                                  sBike.bLeftFlash= 1;
 426                                  sBike.bTurnLeft = 1;
 427                  }
 428                  } else {                                        //OFF
 429                  ucLeftOn = 0;
 430                  if ( ucLeftOff ++ == 10 ){
 431                          ucLeftCount += 50;      //500ms
 432                                  sBike.bLeftFlash = 0;
 433                  } else if ( ucLeftOff > 10 ){
 434                          ucLeftOff = 11;
 435                      sBike.bLFlashType = 1;
 436                      if ( ucLeftCount == 0 ){
 437                                          sBike.bTurnLeft = 0;
 438                      } else
 439                                          ucLeftCount --;
 440                          }
 441                  }
 442                  
 443                  if ( READ_TURN_RIGHT() ){       //ON
 444                  ucRightOff = 0;
 445                  if ( ucRightOn ++ > 10 ){
 446                      if ( ucRightOn > 100 ){
 447                              ucRightOn = 101;
 448                          sBike.bRFlashType = 0;
 449                      }
 450                          if ( ucRightCount < 0xFF-50 ){
 451                                          ucRightCount++;
 452                      }
 453                                  sBike.bRightFlash= 1;
 454                                  sBike.bTurnRight = 1;
 455                  }
 456                  } else {                                        //OFF
 457                  ucRightOn = 0;
 458                  if ( ucRightOff ++ == 10 ){
 459                          ucRightCount += 50;     //500ms
 460                                  sBike.bRightFlash = 0;
 461                  } else if ( ucRightOff > 10 ){
 462                          ucRightOff = 11;
 463                      sBike.bRFlashType = 1;
 464                      if ( ucRightCount == 0 ){
 465                                          sBike.bTurnRight = 0;
 466                      } else
 467                                          ucRightCount --;
 468                          }
 469                  }
 470          }
 471          
 472          uint8_t MileResetTask(void)
 473          {
 474                  static uint16_t uiPreTick=0;
 475                  static uint8_t TaskFlag = TASK_INIT;
 476                  static uint8_t ucCount = 0;
 477                  uint8_t ret=0;
 478                  
 479              if ( TaskFlag == TASK_EXIT )
 480                  return 0;
 481              
 482                  if ( Get_ElapseTick(uiPreTick) > 10000 | sBike.bBraked | sBike.ucSpeed )
 483                          TaskFlag = TASK_EXIT;
C51 COMPILER V9.50a   BIKE                                                                 11/23/2017 17:08:04 PAGE 9   

 484          
 485                  switch( TaskFlag ){
 486                  case TASK_INIT:
 487                          if ( Get_SysTick() < 3000 && sBike.bTurnRight == 1 ){
 488                                  TaskFlag = TASK_STEP1;
 489                                  ucCount = 0;
 490                          }
 491                          break;
 492                  case TASK_STEP1:
 493                          if ( sBike.bLastNear == 0 && sBike.bNearLight ){
 494                                  uiPreTick = Get_SysTick();
 495                                  if ( ++ucCount >= 8 ){
 496                                          TaskFlag = TASK_STEP2;
 497                                          ucCount = 0;
 498                                          sBike.bMileFlash = 1;
 499                                          sBike.ulMile = sConfig.ulMile;
 500                                  } 
 501                          }
 502                          sBike.bLastNear = sBike.bNearLight;
 503                          ret = 1;
 504                          break;
 505                  case TASK_STEP2:
 506                          if ( sBike.bTurnRight == 0 && sBike.bTurnLeft == 1 ) {
 507                                  ucCount = 0;
 508                                  TaskFlag = TASK_EXIT;
 509                                  sBike.bMileFlash = 0;
 510                                  sBike.ulFMile   = 0;
 511                                  sBike.ulMile    = 0;
 512                                  sConfig.ulMile  = 0;
 513                                  WriteConfig();
 514                          } else if ( sBike.bTurnRight == 0 && sBike.bTurnLeft == 0 ) {
 515                                  if ( sBike.bLastNear == 0 && sBike.bNearLight){
 516                                          uiPreTick = Get_SysTick();
 517                                          if ( ++ucCount >= 4 ){
 518                                                  TaskFlag = TASK_STEP3;
 519                                                  if ( sConfig.uiSingleTrip ){
 520                                                          sConfig.uiSingleTrip = 0;
 521                                                          sBike.ulMile = 99999UL;
 522                                                  } else {
 523                                                          sConfig.uiSingleTrip = 1;
 524                                                          sBike.ulMile = 0;
 525                                                  }
 526                                                  WriteConfig();
 527                                          }
 528                                  }
 529                          }
 530                          sBike.bLastNear = sBike.bNearLight;
 531                          ret = 1;
 532                          break;
 533                  case TASK_STEP3:
 534                          if ( Get_ElapseTick(uiPreTick) > 3000 ) {
 535                                  TaskFlag = TASK_EXIT;
 536                                  if ( sConfig.uiSingleTrip )
 537                                          sBike.ulMile = 0;
 538                                  else
 539                                          sBike.ulMile = sConfig.ulMile;
 540                                  sBike.bMileFlash = 0;
 541                          }
 542                          ret = 1;
 543                          break;
 544                  case TASK_EXIT:
 545                  default:
C51 COMPILER V9.50a   BIKE                                                                 11/23/2017 17:08:04 PAGE 10  

 546                          sBike.bMileFlash = 0;
 547                          ret = 0;
 548                          break;
 549                  }
 550                  
 551                  return ret;
 552          }
 553          
 554          void MileTask(void)
 555          {
 556                  static uint16_t uiTime = 0;
 557                  uint8_t uiSpeed;
 558                  
 559                  if ( MileResetTask() )
 560                          return ;
 561                  
 562                  uiSpeed = sBike.ucSpeed;
 563                  if ( uiSpeed > DISPLAY_MAX_SPEED )
 564                          uiSpeed = DISPLAY_MAX_SPEED;
 565          
 566          //#ifdef SINGLE_TRIP
 567                  uiTime ++;
 568                  if ( uiTime < 20 ) {    //2s
 569                          if ( sConfig.uiSingleTrip == 0 )
 570                                  uiTime = 51;
 571                          sBike.ulMile = sConfig.ulMile;
 572                  } else if ( uiTime < 50 ) {     //5s
 573                          if ( uiSpeed ) {
 574                                  uiTime = 50;
 575                                  sBike.ulMile = 0;
 576                          }
 577                  } else if ( uiTime == 50 ){
 578                          sBike.ulMile = 0;
 579                  } else 
 580          //#endif        
 581                  {
 582                          uiTime = 51;
 583                          
 584                          sBike.ulFMile = sBike.ulFMile + uiSpeed;
 585                          if(sBike.ulFMile >= 36000)
 586                          {
 587                                  sBike.ulFMile = 0;
 588                                  sBike.ulMile++;
 589                                  if ( sBike.ulMile > 99999 )             sBike.ulMile = 0;
 590                                  sConfig.ulMile ++;
 591                                  if ( sConfig.ulMile > 99999 )   sConfig.ulMile = 0;
 592                                  WriteConfig();
 593                          }  
 594                  }
 595          }
 596          
 597          uint8_t SpeedCaltTask(void)
 598          {
 599                  static uint16_t uiPreTick=0;
 600                  static uint8_t TaskFlag = TASK_INIT;
 601                  static uint8_t ucLastSpeed = 0;
 602                  static uint8_t ucCount = 0;
 603              static signed char cSpeedInc=0;
 604                  static uint8_t yxterr=0;
 605                  
 606              if ( TaskFlag == TASK_EXIT )
 607                  return 0;
C51 COMPILER V9.50a   BIKE                                                                 11/23/2017 17:08:04 PAGE 11  

 608              
 609                  if ( Get_ElapseTick(uiPreTick) > 10000 || sBike.bBraked )
 610                          TaskFlag = TASK_EXIT;
 611          
 612                  switch( TaskFlag ){
 613                  case TASK_INIT:
 614                          if ( Get_SysTick() < 3000 && sBike.bTurnLeft == 1 ){
 615                                  TaskFlag = TASK_STEP1;
 616                                  ucCount = 0;
 617                          }
 618                          break;
 619                  case TASK_STEP1:
 620                          if ( sBike.bLastNear == 0 && sBike.bNearLight){
 621                                  if ( ++ucCount >= 8 ){
 622                                          TaskFlag = TASK_STEP2;
 623                                          ucCount         = 0;
 624                                          cSpeedInc       = 0;
 625                                          sBike.bSpeedFlash = 1;
 626                                          yxterr = sBike.bYXTERR;
 627                                          if ( yxterr )
 628                                                  sConfig.uiSpeedScale     = 1000;
 629                                          else
 630                                                  sConfig.uiYXT_SpeedScale = 1000;
 631                                  }
 632                                  uiPreTick = Get_SysTick();
 633                          }
 634                          sBike.bLastNear  = sBike.bNearLight;
 635                          break;
 636                  case TASK_STEP2:
 637                  //if ( sConfig.uiSysVoltage == 48 )
 638                          //      sBike.ucSpeed = 42;
 639                  //else if ( sConfig.uiSysVoltage == 60 )
 640                          //      sBike.ucSpeed = 44;
 641                  
 642                          if ( sBike.bLastNear == 0 && sBike.bNearLight == 1 ){
 643                                  uiPreTick = Get_SysTick();
 644                      if ( sBike.bTurnLeft == 1 ) {
 645                                          ucCount = 0;
 646                                          if ( sBike.ucSpeed + cSpeedInc > 1 )
 647                                                  cSpeedInc --;
 648                          } else if ( sBike.bTurnRight == 1 ) {
 649                                          ucCount = 0;
 650                          if ( sBike.ucSpeed + cSpeedInc < 99 )
 651                                                  cSpeedInc ++;
 652                      } else {
 653                                          if ( ++ucCount >= 5 ){
 654                                                  TaskFlag = TASK_EXIT;
 655                                                  sBike.bSpeedFlash = 0;
 656                                                  if ( sBike.ucSpeed ) {
 657                                                          if ( yxterr )
 658                                                                  sConfig.uiSpeedScale     = (uint32_t)sBike.ucSpeed*1000UL/(sBike.ucSpeed+cSpeedInc);
 659                                                          else
 660                                                                  sConfig.uiYXT_SpeedScale = (uint32_t)sBike.ucSpeed*1000UL/(sBike.ucSpeed+cSpeedInc);
 661                                                          WriteConfig();
 662                                                  }
 663                                          }
 664                                  }
 665                          }
 666                          sBike.bLastNear = sBike.bNearLight;
 667              
 668                          if ( ucLastSpeed && sBike.ucSpeed == 0 ){
 669                                  TaskFlag = TASK_EXIT;
C51 COMPILER V9.50a   BIKE                                                                 11/23/2017 17:08:04 PAGE 12  

 670                          }
 671                  
 672                          if ( sBike.ucSpeed )
 673                                  uiPreTick = Get_SysTick();
 674          
 675                  sBike.ucSpeed += cSpeedInc;
 676                          ucLastSpeed = sBike.ucSpeed;
 677                          break;
 678                  case TASK_EXIT:
 679                  default:
 680                          sBike.bSpeedFlash = 0;
 681                          break;
 682                  }
 683                  return 0;
 684          }
 685          
 686          #if ( TIME_ENABLE == 1 )
              void TimeTask(void)
              {
                      static uint8_t ucTask=0,ucLeftOn= 0,NL_on = 0;
                      static uint16_t uiPreTick;
                      
                      if (!sBike.bHasTimer)
                              return ;
                      
                      if (sBike.ucSpeed > 1)
                              ucTask = 0xff;
                      
                      switch ( ucTask ){
                      case 0:
                              if ( Get_SysTick() < 5000 && sBike.bNearLight == 0 && sBike.bTurnLeft == 1 ){
                                      uiPreTick = Get_SysTick();
                                      ucTask++;
                              }
                              break;
                      case 1:
                              if ( sBike.bTurnLeft == 0 ){
                                      if ( Get_ElapseTick(uiPreTick) < 2000  ) ucTask = 0xFF; else { uiPreTick = Get_SysTick(); ucTask++; }
                              } else {
                                      if ( Get_ElapseTick(uiPreTick) > 10000 || sBike.bNearLight ) ucTask = 0xFF;
                              }
                              break;
                      case 2:
                              if ( sBike.bTurnRight == 1 ){
                                      if ( Get_ElapseTick(uiPreTick) > 1000  ) ucTask = 0xFF; else { uiPreTick = Get_SysTick(); ucTask++; }
                              } else {
                                      if ( Get_ElapseTick(uiPreTick) > 1000  || sBike.bNearLight ) ucTask = 0xFF;
                              }
                              break;
                      case 3:
                              if ( sBike.bTurnRight == 0 ){
                                      if ( Get_ElapseTick(uiPreTick) < 2000  ) ucTask = 0xFF; else { uiPreTick = Get_SysTick(); ucTask++; }
                              } else {
                                      if ( Get_ElapseTick(uiPreTick) > 10000 || sBike.bNearLight ) ucTask = 0xFF;
                              }
                              break;
                      case 4:
                              if ( sBike.bTurnLeft == 1 ){
                                      if ( Get_ElapseTick(uiPreTick) > 1000  ) ucTask = 0xFF; else { uiPreTick = Get_SysTick(); ucTask++; }
                              } else {
                                      if ( Get_ElapseTick(uiPreTick) > 1000  || sBike.bNearLight ) ucTask = 0xFF;
                              }
C51 COMPILER V9.50a   BIKE                                                                 11/23/2017 17:08:04 PAGE 13  

                              break;
                      case 5:
                              if ( sBike.bTurnLeft == 0 ){
                                      if ( Get_ElapseTick(uiPreTick) < 2000  ) ucTask = 0xFF; else { uiPreTick = Get_SysTick(); ucTask++; }
                              } else {
                                      if ( Get_ElapseTick(uiPreTick) > 10000 || sBike.bNearLight ) ucTask = 0xFF;
                              }
                              break;
                      case 6:
                              if ( sBike.bTurnRight == 1 ){
                                      if ( Get_ElapseTick(uiPreTick) > 1000  ) ucTask = 0xFF; else { uiPreTick = Get_SysTick(); ucTask++; }
                              } else {
                                      if ( Get_ElapseTick(uiPreTick) > 1000  || sBike.bNearLight ) ucTask = 0xFF;
                              }
                      case 7:
                              if ( sBike.bTurnRight == 0 ){
                                      if ( Get_ElapseTick(uiPreTick) < 2000  ) ucTask = 0xFF; else { uiPreTick = Get_SysTick(); ucTask++; }
                              } else {
                                      if ( Get_ElapseTick(uiPreTick) > 10000 || sBike.bNearLight ) ucTask = 0xFF;
                              }
                              break;
                      case 8:
                              if ( sBike.bTurnLeft == 1 ){
                                      if ( Get_ElapseTick(uiPreTick) > 1000  ) ucTask = 0xFF; else { uiPreTick = Get_SysTick(); ucTask++; }
                              } else {
                                      if ( Get_ElapseTick(uiPreTick) > 1000  || sBike.bNearLight ) ucTask = 0xFF;
                              }
                      case 9:
                              if ( sBike.bTurnLeft == 0 ){
                                      if ( Get_ElapseTick(uiPreTick) < 2000  ) ucTask = 0xFF; else { uiPreTick = Get_SysTick(); ucTask++; }
                              } else {
                                      if ( Get_ElapseTick(uiPreTick) > 10000 || sBike.bNearLight ) ucTask = 0xFF;
                              }
                              break;
                      case 10:
                              if ( sBike.bTurnRight == 1 ){
                                      if ( Get_ElapseTick(uiPreTick) > 1000  ) ucTask = 0xFF; else { uiPreTick = Get_SysTick(); ucTask++; }
                              } else {
                                      if ( Get_ElapseTick(uiPreTick) > 1000  || sBike.bNearLight ) ucTask = 0xFF;
                              }
                      case 11:
                              if ( sBike.bTurnRight == 0 ){
                                      if ( Get_ElapseTick(uiPreTick) < 2000  ) ucTask = 0xFF; else { uiPreTick = Get_SysTick(); ucTask++; }
                              } else {
                                      if ( Get_ElapseTick(uiPreTick) > 10000 || sBike.bNearLight ) ucTask = 0xFF;
                              }
                              break;
                      case 12:
                              if ( sBike.bTurnLeft == 1 || sBike.bNearLight ){
                                       ucTask = 0xFF;
                              } else {
                                      if ( Get_ElapseTick(uiPreTick) > 1000 ) {
                                              ucTask= 0;
                                              sBike.ucTimePos = 0;
                                              sBike.bTimeSet = 1; 
                                              uiPreTick = Get_SysTick();
                                      }
                              }
                              break;
                      default:
                              sBike.ucTimePos = 0;
                              sBike.bTimeSet = 0; 
C51 COMPILER V9.50a   BIKE                                                                 11/23/2017 17:08:04 PAGE 14  

                              ucTask = 0;
                              break;
                      }
              
                      if ( sBike.bTimeSet ){
                              if ( sBike.bTurnLeft ) { ucLeftOn = 1; }
                              if ( sBike.bTurnLeft == 0 ) {
                                      if ( ucLeftOn == 1 ){
                                              sBike.ucTimePos ++;
                                              sBike.ucTimePos %= 4;
                                              ucLeftOn = 0;
                                              uiPreTick = Get_SysTick();
                                      }
                              }
                              if ( sBike.bNearLight ) { NL_on = 1; uiPreTick = Get_SysTick(); }
                              if ( sBike.bNearLight == 0 && NL_on == 1 ) {
                                      NL_on = 0;
                                      if ( Get_ElapseTick(uiPreTick) < 5000 ){
                                              switch ( sBike.ucTimePos ){
                                              case 0:
                                                      sBike.ucHour += 10;
                                                      sBike.ucHour %= 20;
                                                      break;
                                              case 1:
                                                      if ( sBike.ucHour % 10 < 9 )
                                                              sBike.ucHour ++;
                                                      else 
                                                              sBike.ucHour -= 9;
                                                      break;
                                              case 2:
                                                      sBike.ucMinute += 10;
                                                      sBike.ucMinute %= 60;
                                                      break;
                                              case 3:
                                                      if ( sBike.ucMinute % 10 < 9 )
                                                              sBike.ucMinute ++;
                                                      else 
                                                              sBike.ucMinute -= 9;
                                                      break;
                                              default:
                                                      sBike.bTimeSet = 0;
                                                      break;
                                              }
                                      }
                                      RtcTime.RTC_Hours       = sBike.ucHour;
                                      RtcTime.RTC_Minutes = sBike.ucMinute;
                                      PCF8563_SetTime(PCF_Format_BIN,&RtcTime);
                              }
                              if ( Get_ElapseTick(uiPreTick) > 30000 ){
                                      sBike.bTimeSet = 0;
                              }
                      }               
                      
                       PCF8563_GetTime(PCF_Format_BIN,&RtcTime);
                       sBike.ucHour           = RtcTime.RTC_Hours%12;
                       sBike.ucMinute         = RtcTime.RTC_Minutes;
              }
              #endif 
 852          /*----------------------------------------------------------*/
 853          
 854          void Light_Task(void)
 855          {
C51 COMPILER V9.50a   BIKE                                                                 11/23/2017 17:08:04 PAGE 15  

 856                  uint8_t ucSpeedMode;
 857          
 858                  if( GPIO_Read(NearLight_PORT,   NearLight_PIN) ) sBike.bNearLight = 1; else sBike.bNearLight = 0;
 859                  //if( GPIO_Read(TurnRight_PORT, TurnRight_PIN) ) sBike.bTurnRight = 1; else sBike.bTurnRight = 0;
 860                  //if( GPIO_Read(TurnLeft_PORT,  TurnLeft_PIN ) ) sBike.bTurnLeft  = 1; else sBike.bTurnLeft  = 0;
 861                  //if( GPIO_Read(Braked_PORT,    Braked_PIN       ) ) sBike.bBraked    = 1; else sBike.bBraked    = 0;
 862                  
 863                  if ( sBike.bYXTERR ){
 864                          ucSpeedMode = 0;
 865                          if( GPIO_Read(SPMODE1_PORT,SPMODE1_PIN) ) ucSpeedMode |= 1<<0;
 866                          if( GPIO_Read(SPMODE2_PORT,SPMODE2_PIN) ) ucSpeedMode |= 1<<1;
 867                          if( GPIO_Read(SPMODE3_PORT,SPMODE3_PIN) ) ucSpeedMode |= 1<<2;
 868                  #ifdef SPMODE4_PORT
 869                          if( GPIO_Read(SPMODE4_PORT,SPMODE4_PIN) ) ucSpeedMode |= 1<<3;
 870                  #endif
 871                          switch(ucSpeedMode){
 872                                  case 0x01:      sBike.ucSpeedMode = 1; break;
 873                                  case 0x02:      sBike.ucSpeedMode = 2; break;
 874                                  case 0x04:      sBike.ucSpeedMode = 3; break;
 875                                  case 0x08:      sBike.ucSpeedMode = 4; break;
 876                                  default:        sBike.ucSpeedMode = 0; break;
 877                          }
 878                          sBike.ucPHA_Speed= GetSpeed();
 879                          sBike.ucSpeed    = (uint32_t)sBike.ucPHA_Speed*1000UL/sConfig.uiSpeedScale;
 880                  }
 881          }
 882          
 883          void GetSysVoltage(void)
 884          {       
 885          #if defined BENLING_OUSHANG
                      uint16_t uiVol;
                      for(i=0;i<0xFF;i++){
                              if ( GetVolStabed(&uiVol) && (uiVol > 120) ) break;
                              FEED_DOG();  
                      }
                      if ( 720 <= uiVol && uiVol <= 870 ){
                              if ( sConfig.uiSysVoltage != 72 ){
                                      sConfig.uiSysVoltage = 72
                                      WriteConfig();
                              }
                      } else if ( 480 <= uiVol && uiVol <= 600 ){
                              if ( sConfig.uiSysVoltage != 60 ){
                                      sConfig.uiSysVoltage = 60;
                                      WriteConfig();
                              }
                      }
              #elif defined BENLING_BL48_60
                      uint16_t uiVol;
                      for(i=0;i<0xFF;i++){
                              if ( GetVolStabed(&uiVol) && (uiVol > 120) ) break;
                              FEED_DOG();  
                      }
                      if ( 610 <= uiVol && uiVol <= 720 ){
                              if ( sConfig.uiSysVoltage != 60 ){
                                      sConfig.uiSysVoltage = 60;
                                      WriteConfig();
                              }
                      }       else if ( 360 <= uiVol && uiVol <= 500 ){
                              if ( sConfig.uiSysVoltage != 48 ){
                                      sConfig.uiSysVoltage = 48;
                                      WriteConfig();
                              }
C51 COMPILER V9.50a   BIKE                                                                 11/23/2017 17:08:04 PAGE 16  

                      }               
              #elif defined BENLING_ZHONGSHA
                      sConfig.uiSysVoltage = 72;
              #elif (defined OUJUN) || (defined OUPAINONG_6072)
                      //GPIO_Init(V72_PORT, V72_PIN, GPIO_MODE_IN_PU_NO_IT);
                      GPIO_Init(V48_PORT, V48_PIN, GPIO_MODE_IN_PU_NO_IT);
                      if ( GPIO_ReadInputPin(V48_PORT, V48_PIN) == RESET ){
                              sConfig.uiSysVoltage = 72;
                      } else {
                              sConfig.uiSysVoltage = 60;
                      }
              #elif defined OUPAINONG_4860
                      GPIO_Init(V48_PORT, V48_PIN, GPIO_MODE_IN_PU_NO_IT);
                      if ( GPIO_ReadInputPin(V48_PORT, V48_PIN) == RESET ){
                              sConfig.uiSysVoltage = 48;
                      } else {
                              sConfig.uiSysVoltage = 60;
                      }
              #elif defined LCD9040_4860
                      GPIO_Init(V48_PORT, V48_PIN, GPIO_MODE_IN_PU_NO_IT);
                      if ( GPIO_ReadInputPin(V48_PORT, V48_PIN) == RESET ){
                              sConfig.uiSysVoltage = 60;
                      } else {
                              sConfig.uiSysVoltage = 48;
                      }
              #else
 944                  GPIO_Init(V72_PORT, V72_PIN, GPIO_MODE_IN_PU_NO_IT);
 945                  GPIO_Init(V48_PORT, V48_PIN, GPIO_MODE_IN_PU_NO_IT);
 946                  if ( GPIO_ReadInputPin(V72_PORT, V72_PIN) == RESET ){
 947                          sConfig.uiSysVoltage = 72;
 948                  } else {
 949                          if ( GPIO_ReadInputPin(V48_PORT, V48_PIN) == RESET ){
 950                                  sConfig.uiSysVoltage = 48;
 951                          } else {
 952                                  sConfig.uiSysVoltage = 60;
 953                          }
 954                  }
 955          #endif
 956          }
 957          
 958          void Calibration(void)
 959          {
 960                  uint8_t i;
 961                  uint16_t uiVol;
 962                  
 963                  CFG->GCR = CFG_GCR_SWD;
 964                  //¶Ì½ÓµÍËÙ¡¢SWIMÐÅºÅ
 965                  GPIO_Init(GPIOD, GPIO_PIN_1, GPIO_MODE_OUT_OD_HIZ_SLOW);
 966          
 967                  for(i=0;i<32;i++){
 968                          GPIO_WriteLow (GPIOD,GPIO_PIN_1);
 969                          Delay(1000);
 970                          if( GPIO_Read(SPMODE1_PORT      , SPMODE1_PIN) ) break;
 971                          GPIO_WriteHigh (GPIOD,GPIO_PIN_1);
 972                          Delay(1000);
 973                          if( GPIO_Read(SPMODE1_PORT      , SPMODE1_PIN)  == RESET ) break;
 974                  }
 975                  if ( i == 32 ){
 976                          for(i=0;i<0xFF;i++){
 977                                  if ( GetVolStabed(&uiVol) && (uiVol > 120) ) break;
 978                                  FEED_DOG();  
 979                          }
C51 COMPILER V9.50a   BIKE                                                                 11/23/2017 17:08:04 PAGE 17  

 980                          sBike.uiVoltage         = uiVol;
 981                          //sBike.siTemperature= GetTemp();
 982                          //sBike.ucSpeed         = GetSpeed();
 983          
 984                          sConfig.uiVolScale      = (uint32_t)sBike.uiVoltage*1000UL/VOL_CALIBRATIOIN;            //60.00V
 985                          //sConfig.TempScale     = (long)sBike.siTemperature*1000UL/TEMP_CALIBRATIOIN;   //25.0C
 986                          //sConfig.uiSpeedScale = (uint32_t)sBike.ucSpeed*1000UL/SPEED_CALIBRATIOIN;     //30km/h
 987                          //sConfig.ulMile = 0;
 988                          WriteConfig();
 989                  }
 990                  
 991          #if ( TIME_ENABLE == 1 )
                      for(i=0;i<32;i++){
                              GPIO_WriteLow (GPIOD,GPIO_PIN_1);
                              Delay(1000);
                              if( GPIO_Read(SPMODE2_PORT      , SPMODE2_PIN) ) break;
                              GPIO_WriteHigh (GPIOD,GPIO_PIN_1);
                              Delay(1000);
                              if( GPIO_Read(SPMODE2_PORT      , SPMODE2_PIN)  == RESET ) break;
                      }
                      if ( i == 32 ){
                              sBike.bUart = 1;
                      } else
                              sBike.bUart = 0;
              #endif
1005          
1006                  CFG->GCR &= ~CFG_GCR_SWD;
1007          }
1008          
1009          void main(void)
1010          {
1011                  uint8_t i;
1012                  uint16_t uiTick;
1013                  uint16_t uiCount=0;
1014                  uint16_t uiVol=0;
1015                  uint16_t tick_100ms=0;
1016                  
1017                  /* select Clock = 8 MHz */
1018                  CLK_SYSCLKConfig(CLK_PRESCALER_HSIDIV2);
1019                  CLK_HSICmd(ENABLE);
1020                  IWDG_Config();
1021          
1022                  Init_timer();  
1023                  HotReset();
1024                  if ( sBike.bHotReset == 0 ) {
1025                          BL55072_Config(1);
1026                  } else
1027                          BL55072_Config(0);
1028          
1029          //      for(i=0;i<32;i++){      GetVol();       /*FEED_DOG(); */ }
1030          //      for(i=0;i<16;i++){      GetSpeed();     /*FEED_DOG(); */ }
1031                  for(i=0;i<4;i++) {      GetTemp();      FEED_DOG(); }
1032          
1033                  InitConfig();
1034                  Calibration();
1035                  
1036          #if ( TIME_ENABLE == 1 )        
                      //sBike.bHasTimer = !PCF8563_Check();
                      sBike.bHasTimer = PCF8563_GetTime(PCF_Format_BIN,&RtcTime);
                      #ifndef DENGGUAN_XUNYING_T
                      InitUART();
                      #endif
C51 COMPILER V9.50a   BIKE                                                                 11/23/2017 17:08:04 PAGE 18  

              #endif
1043          
1044          #if ( YXT_ENABLE == 1 )
1045                  YXT_Init();  
1046          #endif
1047            
1048                  enableInterrupts();
1049                  
1050                  if ( sBike.bHotReset == 0 ) {
1051                          while ( Get_SysTick() < PON_ALLON_TIME ) FEED_DOG();
1052                          BL55072_Config(0);
1053                  }
1054                  
1055                  GetVolStabed(&uiVol);
1056                  sBike.uiVoltage = (uint32_t)uiVol*1000UL/sConfig.uiVolScale;
1057                  sBike.siTemperature = GetTemp();
1058                  
1059                  while(1){
1060                          uiTick = Get_SysTick();
1061                          
1062                          if ( (uiTick >= tick_100ms && (uiTick - tick_100ms) >= 100 ) || \
1063                                   (uiTick <  tick_100ms && (0xFFFF - tick_100ms + uiTick) >= 100 ) ) {
1064                                  tick_100ms = uiTick;
1065                                  uiCount ++;
1066                                  
1067                                  if ( (uiCount % 5) == 0 ) {
1068                                          if ( GetVolStabed(&uiVol) ){
1069                                                  sBike.uiVoltage = (uint32_t)uiVol*1000UL/sConfig.uiVolScale;
1070                                                  sBike.ucBatStatus= GetBatStatus(sBike.uiVoltage);
1071                                          }
1072                                  }
1073                                  if ( (uiCount % 10) == 0 ){
1074                                          //      sBike.siTemperature= (long)GetTemp()    *1000UL/sConfig.TempScale;
1075                                                  sBike.siTemperature= GetTemp();
1076                                          }
1077                          #ifdef LCD8794GCT
                                      //sBike.ucEnergy        = GetBatEnergy(sBike.uiVoltage);
                              #endif
1080                          
1081                                  Light_Task();
1082                                  MileTask(); 
1083                                  
1084                          #if ( YXT_ENABLE == 1 )
1085                                  YXT_Task(&sBike,&sConfig);  
1086                          #endif
1087                                  
1088                                  SpeedCaltTask();
1089                          
1090                          #if ( TIME_ENABLE == 1 )        
                                      TimeTask();   
                              #endif
1093                
1094                          #ifdef LCD_SEG_TEST
                                      if ( ++uiCount >= 100 ) uiCount = 0;
                                      sBike.uiVoltage         = uiCount/10 + uiCount/10*10UL + uiCount/10*100UL + uiCount/10*1000UL;
                                      sBike.siTemperature     = uiCount/10 + uiCount/10*10UL + uiCount/10*100UL;
                                      sBike.ucSpeed           = uiCount/10 + uiCount/10*10;
                                      sBike.ulMile            = uiCount/10 + uiCount/10*10UL + uiCount/10*100UL + uiCount/10*1000UL + uiCount/10*10000U
             -L;
                                      sBike.ucHour            = uiCount/10 + uiCount/10*10;
                                      sBike.ucMinute          = uiCount/10 + uiCount/10*10;
                                      #ifdef LCD8794GCT
C51 COMPILER V9.50a   BIKE                                                                 11/23/2017 17:08:04 PAGE 19  

                                      //sBike.ucEnergy    = uiCount/10 + uiCount/10*10UL;
                                      #endif
                              #endif
1106                  
1107                                  MenuUpdate(&sBike);
1108                                  
1109                                  /* Reload IWDG counter */
1110                                  FEED_DOG();  
1111                          } 
1112          
1113                  #if ( TIME_ENABLE == 1 )
                              #ifndef DENGGUAN_XUNYING_T
                              UartTask();
                              #endif
                      #endif
1118                  }
1119          }
1120          
1121          
1122          /************************ (C) COPYRIGHT  *****END OF FILE****/

C51 COMPILATION COMPLETE.  1 WARNING(S),  4 ERROR(S)
